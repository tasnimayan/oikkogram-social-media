schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "accounts"
"""
type accounts {
  access_token: String
  expires_at: bigint
  id: uuid!
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String!
  providerAccountId: String!
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "accounts"
"""
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

input accounts_aggregate_bool_exp {
  count: accounts_aggregate_bool_exp_count
}

input accounts_aggregate_bool_exp_count {
  arguments: [accounts_select_column!]
  distinct: Boolean
  filter: accounts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "accounts"
"""
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int!
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

"""
order by aggregate values of table "accounts"
"""
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}

"""
input type for inserting array relation for remote table "accounts"
"""
input accounts_arr_rel_insert_input {
  data: [accounts_insert_input!]!

  """upsert condition"""
  on_conflict: accounts_on_conflict
}

"""aggregate avg on columns"""
type accounts_avg_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by avg() on columns of table "accounts"
"""
input accounts_avg_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""
Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
"""
input accounts_bool_exp {
  _and: [accounts_bool_exp!]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp!]
  access_token: String_comparison_exp
  expires_at: bigint_comparison_exp
  id: uuid_comparison_exp
  id_token: String_comparison_exp
  oauth_token: String_comparison_exp
  oauth_token_secret: String_comparison_exp
  provider: String_comparison_exp
  providerAccountId: String_comparison_exp
  refresh_token: String_comparison_exp
  refresh_token_expires_in: Int_comparison_exp
  scope: String_comparison_exp
  session_state: String_comparison_exp
  token_type: String_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "accounts"
"""
enum accounts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  accounts_pkey
}

"""
input type for incrementing numeric columns in table "accounts"
"""
input accounts_inc_input {
  expires_at: bigint
  refresh_token_expires_in: Int
}

"""
input type for inserting data into table "accounts"
"""
input accounts_insert_input {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type accounts_max_fields {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""
order by max() on columns of table "accounts"
"""
input accounts_max_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}

"""aggregate min on columns"""
type accounts_min_fields {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""
order by min() on columns of table "accounts"
"""
input accounts_min_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  userId: order_by
}

"""
response of any mutation on the table "accounts"
"""
type accounts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [accounts!]!
}

"""
on_conflict condition type for table "accounts"
"""
input accounts_on_conflict {
  constraint: accounts_constraint!
  update_columns: [accounts_update_column!]! = []
  where: accounts_bool_exp
}

"""Ordering options when selecting data from "accounts"."""
input accounts_order_by {
  access_token: order_by
  expires_at: order_by
  id: order_by
  id_token: order_by
  oauth_token: order_by
  oauth_token_secret: order_by
  provider: order_by
  providerAccountId: order_by
  refresh_token: order_by
  refresh_token_expires_in: order_by
  scope: order_by
  session_state: order_by
  token_type: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: accounts"""
input accounts_pk_columns_input {
  id: uuid!
}

"""
select columns of table "accounts"
"""
enum accounts_select_column {
  """column name"""
  access_token

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  id_token

  """column name"""
  oauth_token

  """column name"""
  oauth_token_secret

  """column name"""
  provider

  """column name"""
  providerAccountId

  """column name"""
  refresh_token

  """column name"""
  refresh_token_expires_in

  """column name"""
  scope

  """column name"""
  session_state

  """column name"""
  token_type

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "accounts"
"""
input accounts_set_input {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""aggregate stddev on columns"""
type accounts_stddev_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by stddev() on columns of table "accounts"
"""
input accounts_stddev_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate stddev_pop on columns"""
type accounts_stddev_pop_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by stddev_pop() on columns of table "accounts"
"""
input accounts_stddev_pop_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate stddev_samp on columns"""
type accounts_stddev_samp_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by stddev_samp() on columns of table "accounts"
"""
input accounts_stddev_samp_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""
Streaming cursor of the table "accounts"
"""
input accounts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: accounts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input accounts_stream_cursor_value_input {
  access_token: String
  expires_at: bigint
  id: uuid
  id_token: String
  oauth_token: String
  oauth_token_secret: String
  provider: String
  providerAccountId: String
  refresh_token: String
  refresh_token_expires_in: Int
  scope: String
  session_state: String
  token_type: String
  type: String
  userId: uuid
}

"""aggregate sum on columns"""
type accounts_sum_fields {
  expires_at: bigint
  refresh_token_expires_in: Int
}

"""
order by sum() on columns of table "accounts"
"""
input accounts_sum_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""
update columns of table "accounts"
"""
enum accounts_update_column {
  """column name"""
  access_token

  """column name"""
  expires_at

  """column name"""
  id

  """column name"""
  id_token

  """column name"""
  oauth_token

  """column name"""
  oauth_token_secret

  """column name"""
  provider

  """column name"""
  providerAccountId

  """column name"""
  refresh_token

  """column name"""
  refresh_token_expires_in

  """column name"""
  scope

  """column name"""
  session_state

  """column name"""
  token_type

  """column name"""
  type

  """column name"""
  userId
}

input accounts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: accounts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: accounts_set_input

  """filter the rows which have to be updated"""
  where: accounts_bool_exp!
}

"""aggregate var_pop on columns"""
type accounts_var_pop_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by var_pop() on columns of table "accounts"
"""
input accounts_var_pop_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate var_samp on columns"""
type accounts_var_samp_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by var_samp() on columns of table "accounts"
"""
input accounts_var_samp_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""aggregate variance on columns"""
type accounts_variance_fields {
  expires_at: Float
  refresh_token_expires_in: Float
}

"""
order by variance() on columns of table "accounts"
"""
input accounts_variance_order_by {
  expires_at: order_by
  refresh_token_expires_in: order_by
}

"""
columns and relationships of "attachments"
"""
type attachments {
  created_at: timestamptz!
  file_size: Int!
  file_type: String!
  file_url: String!
  id: Int!
  key: String

  """An object relationship"""
  message: messages
  message_id: bigint

  """An object relationship"""
  post: posts
  post_id: bigint
}

"""
aggregated selection of "attachments"
"""
type attachments_aggregate {
  aggregate: attachments_aggregate_fields
  nodes: [attachments!]!
}

input attachments_aggregate_bool_exp {
  count: attachments_aggregate_bool_exp_count
}

input attachments_aggregate_bool_exp_count {
  arguments: [attachments_select_column!]
  distinct: Boolean
  filter: attachments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "attachments"
"""
type attachments_aggregate_fields {
  avg: attachments_avg_fields
  count(columns: [attachments_select_column!], distinct: Boolean): Int!
  max: attachments_max_fields
  min: attachments_min_fields
  stddev: attachments_stddev_fields
  stddev_pop: attachments_stddev_pop_fields
  stddev_samp: attachments_stddev_samp_fields
  sum: attachments_sum_fields
  var_pop: attachments_var_pop_fields
  var_samp: attachments_var_samp_fields
  variance: attachments_variance_fields
}

"""
order by aggregate values of table "attachments"
"""
input attachments_aggregate_order_by {
  avg: attachments_avg_order_by
  count: order_by
  max: attachments_max_order_by
  min: attachments_min_order_by
  stddev: attachments_stddev_order_by
  stddev_pop: attachments_stddev_pop_order_by
  stddev_samp: attachments_stddev_samp_order_by
  sum: attachments_sum_order_by
  var_pop: attachments_var_pop_order_by
  var_samp: attachments_var_samp_order_by
  variance: attachments_variance_order_by
}

"""
input type for inserting array relation for remote table "attachments"
"""
input attachments_arr_rel_insert_input {
  data: [attachments_insert_input!]!

  """upsert condition"""
  on_conflict: attachments_on_conflict
}

"""aggregate avg on columns"""
type attachments_avg_fields {
  file_size: Float
  id: Float
  message_id: Float
  post_id: Float
}

"""
order by avg() on columns of table "attachments"
"""
input attachments_avg_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

"""
Boolean expression to filter rows from the table "attachments". All fields are combined with a logical 'AND'.
"""
input attachments_bool_exp {
  _and: [attachments_bool_exp!]
  _not: attachments_bool_exp
  _or: [attachments_bool_exp!]
  created_at: timestamptz_comparison_exp
  file_size: Int_comparison_exp
  file_type: String_comparison_exp
  file_url: String_comparison_exp
  id: Int_comparison_exp
  key: String_comparison_exp
  message: messages_bool_exp
  message_id: bigint_comparison_exp
  post: posts_bool_exp
  post_id: bigint_comparison_exp
}

"""
unique or primary key constraints on table "attachments"
"""
enum attachments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  attachments_pkey
}

"""
input type for incrementing numeric columns in table "attachments"
"""
input attachments_inc_input {
  file_size: Int
  id: Int
  message_id: bigint
  post_id: bigint
}

"""
input type for inserting data into table "attachments"
"""
input attachments_insert_input {
  created_at: timestamptz
  file_size: Int
  file_type: String
  file_url: String
  id: Int
  key: String
  message: messages_obj_rel_insert_input
  message_id: bigint
  post: posts_obj_rel_insert_input
  post_id: bigint
}

"""aggregate max on columns"""
type attachments_max_fields {
  created_at: timestamptz
  file_size: Int
  file_type: String
  file_url: String
  id: Int
  key: String
  message_id: bigint
  post_id: bigint
}

"""
order by max() on columns of table "attachments"
"""
input attachments_max_order_by {
  created_at: order_by
  file_size: order_by
  file_type: order_by
  file_url: order_by
  id: order_by
  key: order_by
  message_id: order_by
  post_id: order_by
}

"""aggregate min on columns"""
type attachments_min_fields {
  created_at: timestamptz
  file_size: Int
  file_type: String
  file_url: String
  id: Int
  key: String
  message_id: bigint
  post_id: bigint
}

"""
order by min() on columns of table "attachments"
"""
input attachments_min_order_by {
  created_at: order_by
  file_size: order_by
  file_type: order_by
  file_url: order_by
  id: order_by
  key: order_by
  message_id: order_by
  post_id: order_by
}

"""
response of any mutation on the table "attachments"
"""
type attachments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [attachments!]!
}

"""
on_conflict condition type for table "attachments"
"""
input attachments_on_conflict {
  constraint: attachments_constraint!
  update_columns: [attachments_update_column!]! = []
  where: attachments_bool_exp
}

"""Ordering options when selecting data from "attachments"."""
input attachments_order_by {
  created_at: order_by
  file_size: order_by
  file_type: order_by
  file_url: order_by
  id: order_by
  key: order_by
  message: messages_order_by
  message_id: order_by
  post: posts_order_by
  post_id: order_by
}

"""primary key columns input for table: attachments"""
input attachments_pk_columns_input {
  id: Int!
}

"""
select columns of table "attachments"
"""
enum attachments_select_column {
  """column name"""
  created_at

  """column name"""
  file_size

  """column name"""
  file_type

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  key

  """column name"""
  message_id

  """column name"""
  post_id
}

"""
input type for updating data in table "attachments"
"""
input attachments_set_input {
  created_at: timestamptz
  file_size: Int
  file_type: String
  file_url: String
  id: Int
  key: String
  message_id: bigint
  post_id: bigint
}

"""aggregate stddev on columns"""
type attachments_stddev_fields {
  file_size: Float
  id: Float
  message_id: Float
  post_id: Float
}

"""
order by stddev() on columns of table "attachments"
"""
input attachments_stddev_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

"""aggregate stddev_pop on columns"""
type attachments_stddev_pop_fields {
  file_size: Float
  id: Float
  message_id: Float
  post_id: Float
}

"""
order by stddev_pop() on columns of table "attachments"
"""
input attachments_stddev_pop_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

"""aggregate stddev_samp on columns"""
type attachments_stddev_samp_fields {
  file_size: Float
  id: Float
  message_id: Float
  post_id: Float
}

"""
order by stddev_samp() on columns of table "attachments"
"""
input attachments_stddev_samp_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

"""
Streaming cursor of the table "attachments"
"""
input attachments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: attachments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input attachments_stream_cursor_value_input {
  created_at: timestamptz
  file_size: Int
  file_type: String
  file_url: String
  id: Int
  key: String
  message_id: bigint
  post_id: bigint
}

"""aggregate sum on columns"""
type attachments_sum_fields {
  file_size: Int
  id: Int
  message_id: bigint
  post_id: bigint
}

"""
order by sum() on columns of table "attachments"
"""
input attachments_sum_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

"""
update columns of table "attachments"
"""
enum attachments_update_column {
  """column name"""
  created_at

  """column name"""
  file_size

  """column name"""
  file_type

  """column name"""
  file_url

  """column name"""
  id

  """column name"""
  key

  """column name"""
  message_id

  """column name"""
  post_id
}

input attachments_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: attachments_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: attachments_set_input

  """filter the rows which have to be updated"""
  where: attachments_bool_exp!
}

"""aggregate var_pop on columns"""
type attachments_var_pop_fields {
  file_size: Float
  id: Float
  message_id: Float
  post_id: Float
}

"""
order by var_pop() on columns of table "attachments"
"""
input attachments_var_pop_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

"""aggregate var_samp on columns"""
type attachments_var_samp_fields {
  file_size: Float
  id: Float
  message_id: Float
  post_id: Float
}

"""
order by var_samp() on columns of table "attachments"
"""
input attachments_var_samp_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

"""aggregate variance on columns"""
type attachments_variance_fields {
  file_size: Float
  id: Float
  message_id: Float
  post_id: Float
}

"""
order by variance() on columns of table "attachments"
"""
input attachments_variance_order_by {
  file_size: order_by
  id: order_by
  message_id: order_by
  post_id: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "bookmarks"
"""
type bookmarks {
  created_at: timestamptz!

  """An object relationship"""
  post: posts!
  post_id: Int!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "bookmarks"
"""
type bookmarks_aggregate {
  aggregate: bookmarks_aggregate_fields
  nodes: [bookmarks!]!
}

input bookmarks_aggregate_bool_exp {
  count: bookmarks_aggregate_bool_exp_count
}

input bookmarks_aggregate_bool_exp_count {
  arguments: [bookmarks_select_column!]
  distinct: Boolean
  filter: bookmarks_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "bookmarks"
"""
type bookmarks_aggregate_fields {
  avg: bookmarks_avg_fields
  count(columns: [bookmarks_select_column!], distinct: Boolean): Int!
  max: bookmarks_max_fields
  min: bookmarks_min_fields
  stddev: bookmarks_stddev_fields
  stddev_pop: bookmarks_stddev_pop_fields
  stddev_samp: bookmarks_stddev_samp_fields
  sum: bookmarks_sum_fields
  var_pop: bookmarks_var_pop_fields
  var_samp: bookmarks_var_samp_fields
  variance: bookmarks_variance_fields
}

"""
order by aggregate values of table "bookmarks"
"""
input bookmarks_aggregate_order_by {
  avg: bookmarks_avg_order_by
  count: order_by
  max: bookmarks_max_order_by
  min: bookmarks_min_order_by
  stddev: bookmarks_stddev_order_by
  stddev_pop: bookmarks_stddev_pop_order_by
  stddev_samp: bookmarks_stddev_samp_order_by
  sum: bookmarks_sum_order_by
  var_pop: bookmarks_var_pop_order_by
  var_samp: bookmarks_var_samp_order_by
  variance: bookmarks_variance_order_by
}

"""
input type for inserting array relation for remote table "bookmarks"
"""
input bookmarks_arr_rel_insert_input {
  data: [bookmarks_insert_input!]!

  """upsert condition"""
  on_conflict: bookmarks_on_conflict
}

"""aggregate avg on columns"""
type bookmarks_avg_fields {
  post_id: Float
}

"""
order by avg() on columns of table "bookmarks"
"""
input bookmarks_avg_order_by {
  post_id: order_by
}

"""
Boolean expression to filter rows from the table "bookmarks". All fields are combined with a logical 'AND'.
"""
input bookmarks_bool_exp {
  _and: [bookmarks_bool_exp!]
  _not: bookmarks_bool_exp
  _or: [bookmarks_bool_exp!]
  created_at: timestamptz_comparison_exp
  post: posts_bool_exp
  post_id: Int_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "bookmarks"
"""
enum bookmarks_constraint {
  """
  unique or primary key constraint on columns "user_id", "post_id"
  """
  bookmarks_pkey
}

"""
input type for incrementing numeric columns in table "bookmarks"
"""
input bookmarks_inc_input {
  post_id: Int
}

"""
input type for inserting data into table "bookmarks"
"""
input bookmarks_insert_input {
  created_at: timestamptz
  post: posts_obj_rel_insert_input
  post_id: Int
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type bookmarks_max_fields {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""
order by max() on columns of table "bookmarks"
"""
input bookmarks_max_order_by {
  created_at: order_by
  post_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type bookmarks_min_fields {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""
order by min() on columns of table "bookmarks"
"""
input bookmarks_min_order_by {
  created_at: order_by
  post_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "bookmarks"
"""
type bookmarks_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bookmarks!]!
}

"""
on_conflict condition type for table "bookmarks"
"""
input bookmarks_on_conflict {
  constraint: bookmarks_constraint!
  update_columns: [bookmarks_update_column!]! = []
  where: bookmarks_bool_exp
}

"""Ordering options when selecting data from "bookmarks"."""
input bookmarks_order_by {
  created_at: order_by
  post: posts_order_by
  post_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: bookmarks"""
input bookmarks_pk_columns_input {
  post_id: Int!
  user_id: uuid!
}

"""
select columns of table "bookmarks"
"""
enum bookmarks_select_column {
  """column name"""
  created_at

  """column name"""
  post_id

  """column name"""
  user_id
}

"""
input type for updating data in table "bookmarks"
"""
input bookmarks_set_input {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type bookmarks_stddev_fields {
  post_id: Float
}

"""
order by stddev() on columns of table "bookmarks"
"""
input bookmarks_stddev_order_by {
  post_id: order_by
}

"""aggregate stddev_pop on columns"""
type bookmarks_stddev_pop_fields {
  post_id: Float
}

"""
order by stddev_pop() on columns of table "bookmarks"
"""
input bookmarks_stddev_pop_order_by {
  post_id: order_by
}

"""aggregate stddev_samp on columns"""
type bookmarks_stddev_samp_fields {
  post_id: Float
}

"""
order by stddev_samp() on columns of table "bookmarks"
"""
input bookmarks_stddev_samp_order_by {
  post_id: order_by
}

"""
Streaming cursor of the table "bookmarks"
"""
input bookmarks_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: bookmarks_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input bookmarks_stream_cursor_value_input {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""aggregate sum on columns"""
type bookmarks_sum_fields {
  post_id: Int
}

"""
order by sum() on columns of table "bookmarks"
"""
input bookmarks_sum_order_by {
  post_id: order_by
}

"""
update columns of table "bookmarks"
"""
enum bookmarks_update_column {
  """column name"""
  created_at

  """column name"""
  post_id

  """column name"""
  user_id
}

input bookmarks_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: bookmarks_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: bookmarks_set_input

  """filter the rows which have to be updated"""
  where: bookmarks_bool_exp!
}

"""aggregate var_pop on columns"""
type bookmarks_var_pop_fields {
  post_id: Float
}

"""
order by var_pop() on columns of table "bookmarks"
"""
input bookmarks_var_pop_order_by {
  post_id: order_by
}

"""aggregate var_samp on columns"""
type bookmarks_var_samp_fields {
  post_id: Float
}

"""
order by var_samp() on columns of table "bookmarks"
"""
input bookmarks_var_samp_order_by {
  post_id: order_by
}

"""aggregate variance on columns"""
type bookmarks_variance_fields {
  post_id: Float
}

"""
order by variance() on columns of table "bookmarks"
"""
input bookmarks_variance_order_by {
  post_id: order_by
}

"""
columns and relationships of "cause_supporters"
"""
type cause_supporters {
  """An object relationship"""
  cause: causes!
  cause_id: uuid!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "cause_supporters"
"""
type cause_supporters_aggregate {
  aggregate: cause_supporters_aggregate_fields
  nodes: [cause_supporters!]!
}

input cause_supporters_aggregate_bool_exp {
  count: cause_supporters_aggregate_bool_exp_count
}

input cause_supporters_aggregate_bool_exp_count {
  arguments: [cause_supporters_select_column!]
  distinct: Boolean
  filter: cause_supporters_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "cause_supporters"
"""
type cause_supporters_aggregate_fields {
  avg: cause_supporters_avg_fields
  count(columns: [cause_supporters_select_column!], distinct: Boolean): Int!
  max: cause_supporters_max_fields
  min: cause_supporters_min_fields
  stddev: cause_supporters_stddev_fields
  stddev_pop: cause_supporters_stddev_pop_fields
  stddev_samp: cause_supporters_stddev_samp_fields
  sum: cause_supporters_sum_fields
  var_pop: cause_supporters_var_pop_fields
  var_samp: cause_supporters_var_samp_fields
  variance: cause_supporters_variance_fields
}

"""
order by aggregate values of table "cause_supporters"
"""
input cause_supporters_aggregate_order_by {
  avg: cause_supporters_avg_order_by
  count: order_by
  max: cause_supporters_max_order_by
  min: cause_supporters_min_order_by
  stddev: cause_supporters_stddev_order_by
  stddev_pop: cause_supporters_stddev_pop_order_by
  stddev_samp: cause_supporters_stddev_samp_order_by
  sum: cause_supporters_sum_order_by
  var_pop: cause_supporters_var_pop_order_by
  var_samp: cause_supporters_var_samp_order_by
  variance: cause_supporters_variance_order_by
}

"""
input type for inserting array relation for remote table "cause_supporters"
"""
input cause_supporters_arr_rel_insert_input {
  data: [cause_supporters_insert_input!]!

  """upsert condition"""
  on_conflict: cause_supporters_on_conflict
}

"""aggregate avg on columns"""
type cause_supporters_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "cause_supporters"
"""
input cause_supporters_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "cause_supporters". All fields are combined with a logical 'AND'.
"""
input cause_supporters_bool_exp {
  _and: [cause_supporters_bool_exp!]
  _not: cause_supporters_bool_exp
  _or: [cause_supporters_bool_exp!]
  cause: causes_bool_exp
  cause_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "cause_supporters"
"""
enum cause_supporters_constraint {
  """
  unique or primary key constraint on columns "user_id", "cause_id"
  """
  cause_supporters_cause_id_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  cause_supporters_pkey
}

"""
input type for incrementing numeric columns in table "cause_supporters"
"""
input cause_supporters_inc_input {
  id: bigint
}

"""
input type for inserting data into table "cause_supporters"
"""
input cause_supporters_insert_input {
  cause: causes_obj_rel_insert_input
  cause_id: uuid
  created_at: timestamptz
  id: bigint
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type cause_supporters_max_fields {
  cause_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""
order by max() on columns of table "cause_supporters"
"""
input cause_supporters_max_order_by {
  cause_id: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type cause_supporters_min_fields {
  cause_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""
order by min() on columns of table "cause_supporters"
"""
input cause_supporters_min_order_by {
  cause_id: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "cause_supporters"
"""
type cause_supporters_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [cause_supporters!]!
}

"""
input type for inserting object relation for remote table "cause_supporters"
"""
input cause_supporters_obj_rel_insert_input {
  data: cause_supporters_insert_input!

  """upsert condition"""
  on_conflict: cause_supporters_on_conflict
}

"""
on_conflict condition type for table "cause_supporters"
"""
input cause_supporters_on_conflict {
  constraint: cause_supporters_constraint!
  update_columns: [cause_supporters_update_column!]! = []
  where: cause_supporters_bool_exp
}

"""Ordering options when selecting data from "cause_supporters"."""
input cause_supporters_order_by {
  cause: causes_order_by
  cause_id: order_by
  created_at: order_by
  id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: cause_supporters"""
input cause_supporters_pk_columns_input {
  id: bigint!
}

"""
select columns of table "cause_supporters"
"""
enum cause_supporters_select_column {
  """column name"""
  cause_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  user_id
}

"""
input type for updating data in table "cause_supporters"
"""
input cause_supporters_set_input {
  cause_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""aggregate stddev on columns"""
type cause_supporters_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "cause_supporters"
"""
input cause_supporters_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type cause_supporters_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "cause_supporters"
"""
input cause_supporters_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type cause_supporters_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "cause_supporters"
"""
input cause_supporters_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "cause_supporters"
"""
input cause_supporters_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: cause_supporters_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input cause_supporters_stream_cursor_value_input {
  cause_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""aggregate sum on columns"""
type cause_supporters_sum_fields {
  id: bigint
}

"""
order by sum() on columns of table "cause_supporters"
"""
input cause_supporters_sum_order_by {
  id: order_by
}

"""
update columns of table "cause_supporters"
"""
enum cause_supporters_update_column {
  """column name"""
  cause_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  user_id
}

input cause_supporters_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: cause_supporters_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: cause_supporters_set_input

  """filter the rows which have to be updated"""
  where: cause_supporters_bool_exp!
}

"""aggregate var_pop on columns"""
type cause_supporters_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "cause_supporters"
"""
input cause_supporters_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type cause_supporters_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "cause_supporters"
"""
input cause_supporters_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type cause_supporters_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "cause_supporters"
"""
input cause_supporters_variance_order_by {
  id: order_by
}

"""
columns and relationships of "causes"
"""
type causes {
  category: String!

  """An object relationship"""
  cause_supporter: cause_supporters

  """An array relationship"""
  cause_supporters(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): [cause_supporters!]!

  """An aggregate relationship"""
  cause_supporters_aggregate(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): cause_supporters_aggregate!
  cover_img_url: String
  created_at: timestamptz!
  created_by: uuid!
  current_value: Int!
  deleted_at: timestamptz
  description: String
  end_date: timestamptz
  goal_type: String!
  goal_value: Int
  id: uuid!
  location: String!
  neighborhood_id: uuid!
  start_date: timestamptz!

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: String!
  tags: [String!]
  title: String!
  updated_at: timestamptz

  """An object relationship"""
  user: users!

  """An array relationship"""
  volunteers(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): [volunteers!]!

  """An aggregate relationship"""
  volunteers_aggregate(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): volunteers_aggregate!
}

"""
aggregated selection of "causes"
"""
type causes_aggregate {
  aggregate: causes_aggregate_fields
  nodes: [causes!]!
}

input causes_aggregate_bool_exp {
  count: causes_aggregate_bool_exp_count
}

input causes_aggregate_bool_exp_count {
  arguments: [causes_select_column!]
  distinct: Boolean
  filter: causes_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "causes"
"""
type causes_aggregate_fields {
  avg: causes_avg_fields
  count(columns: [causes_select_column!], distinct: Boolean): Int!
  max: causes_max_fields
  min: causes_min_fields
  stddev: causes_stddev_fields
  stddev_pop: causes_stddev_pop_fields
  stddev_samp: causes_stddev_samp_fields
  sum: causes_sum_fields
  var_pop: causes_var_pop_fields
  var_samp: causes_var_samp_fields
  variance: causes_variance_fields
}

"""
order by aggregate values of table "causes"
"""
input causes_aggregate_order_by {
  avg: causes_avg_order_by
  count: order_by
  max: causes_max_order_by
  min: causes_min_order_by
  stddev: causes_stddev_order_by
  stddev_pop: causes_stddev_pop_order_by
  stddev_samp: causes_stddev_samp_order_by
  sum: causes_sum_order_by
  var_pop: causes_var_pop_order_by
  var_samp: causes_var_samp_order_by
  variance: causes_variance_order_by
}

"""
input type for inserting array relation for remote table "causes"
"""
input causes_arr_rel_insert_input {
  data: [causes_insert_input!]!

  """upsert condition"""
  on_conflict: causes_on_conflict
}

"""aggregate avg on columns"""
type causes_avg_fields {
  current_value: Float
  goal_value: Float
}

"""
order by avg() on columns of table "causes"
"""
input causes_avg_order_by {
  current_value: order_by
  goal_value: order_by
}

"""
Boolean expression to filter rows from the table "causes". All fields are combined with a logical 'AND'.
"""
input causes_bool_exp {
  _and: [causes_bool_exp!]
  _not: causes_bool_exp
  _or: [causes_bool_exp!]
  category: String_comparison_exp
  cause_supporter: cause_supporters_bool_exp
  cause_supporters: cause_supporters_bool_exp
  cause_supporters_aggregate: cause_supporters_aggregate_bool_exp
  cover_img_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  current_value: Int_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  end_date: timestamptz_comparison_exp
  goal_type: String_comparison_exp
  goal_value: Int_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  neighborhood_id: uuid_comparison_exp
  start_date: timestamptz_comparison_exp
  status: String_comparison_exp
  tags: String_array_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  volunteers: volunteers_bool_exp
  volunteers_aggregate: volunteers_aggregate_bool_exp
}

"""
unique or primary key constraints on table "causes"
"""
enum causes_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  causes_pkey
}

"""
input type for incrementing numeric columns in table "causes"
"""
input causes_inc_input {
  current_value: Int
  goal_value: Int
}

"""
input type for inserting data into table "causes"
"""
input causes_insert_input {
  category: String
  cause_supporter: cause_supporters_obj_rel_insert_input
  cause_supporters: cause_supporters_arr_rel_insert_input
  cover_img_url: String
  created_at: timestamptz
  created_by: uuid
  current_value: Int
  deleted_at: timestamptz
  description: String
  end_date: timestamptz
  goal_type: String
  goal_value: Int
  id: uuid
  location: String
  neighborhood_id: uuid
  start_date: timestamptz

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  volunteers: volunteers_arr_rel_insert_input
}

"""aggregate max on columns"""
type causes_max_fields {
  category: String
  cover_img_url: String
  created_at: timestamptz
  created_by: uuid
  current_value: Int
  deleted_at: timestamptz
  description: String
  end_date: timestamptz
  goal_type: String
  goal_value: Int
  id: uuid
  location: String
  neighborhood_id: uuid
  start_date: timestamptz

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "causes"
"""
input causes_max_order_by {
  category: order_by
  cover_img_url: order_by
  created_at: order_by
  created_by: order_by
  current_value: order_by
  deleted_at: order_by
  description: order_by
  end_date: order_by
  goal_type: order_by
  goal_value: order_by
  id: order_by
  location: order_by
  neighborhood_id: order_by
  start_date: order_by

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: order_by
  tags: order_by
  title: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type causes_min_fields {
  category: String
  cover_img_url: String
  created_at: timestamptz
  created_by: uuid
  current_value: Int
  deleted_at: timestamptz
  description: String
  end_date: timestamptz
  goal_type: String
  goal_value: Int
  id: uuid
  location: String
  neighborhood_id: uuid
  start_date: timestamptz

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "causes"
"""
input causes_min_order_by {
  category: order_by
  cover_img_url: order_by
  created_at: order_by
  created_by: order_by
  current_value: order_by
  deleted_at: order_by
  description: order_by
  end_date: order_by
  goal_type: order_by
  goal_value: order_by
  id: order_by
  location: order_by
  neighborhood_id: order_by
  start_date: order_by

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: order_by
  tags: order_by
  title: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "causes"
"""
type causes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [causes!]!
}

"""
input type for inserting object relation for remote table "causes"
"""
input causes_obj_rel_insert_input {
  data: causes_insert_input!

  """upsert condition"""
  on_conflict: causes_on_conflict
}

"""
on_conflict condition type for table "causes"
"""
input causes_on_conflict {
  constraint: causes_constraint!
  update_columns: [causes_update_column!]! = []
  where: causes_bool_exp
}

"""Ordering options when selecting data from "causes"."""
input causes_order_by {
  category: order_by
  cause_supporter: cause_supporters_order_by
  cause_supporters_aggregate: cause_supporters_aggregate_order_by
  cover_img_url: order_by
  created_at: order_by
  created_by: order_by
  current_value: order_by
  deleted_at: order_by
  description: order_by
  end_date: order_by
  goal_type: order_by
  goal_value: order_by
  id: order_by
  location: order_by
  neighborhood_id: order_by
  start_date: order_by
  status: order_by
  tags: order_by
  title: order_by
  updated_at: order_by
  user: users_order_by
  volunteers_aggregate: volunteers_aggregate_order_by
}

"""primary key columns input for table: causes"""
input causes_pk_columns_input {
  id: uuid!
}

"""
select columns of table "causes"
"""
enum causes_select_column {
  """column name"""
  category

  """column name"""
  cover_img_url

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  current_value

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  goal_type

  """column name"""
  goal_value

  """column name"""
  id

  """column name"""
  location

  """column name"""
  neighborhood_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  updated_at
}

"""
input type for updating data in table "causes"
"""
input causes_set_input {
  category: String
  cover_img_url: String
  created_at: timestamptz
  created_by: uuid
  current_value: Int
  deleted_at: timestamptz
  description: String
  end_date: timestamptz
  goal_type: String
  goal_value: Int
  id: uuid
  location: String
  neighborhood_id: uuid
  start_date: timestamptz

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type causes_stddev_fields {
  current_value: Float
  goal_value: Float
}

"""
order by stddev() on columns of table "causes"
"""
input causes_stddev_order_by {
  current_value: order_by
  goal_value: order_by
}

"""aggregate stddev_pop on columns"""
type causes_stddev_pop_fields {
  current_value: Float
  goal_value: Float
}

"""
order by stddev_pop() on columns of table "causes"
"""
input causes_stddev_pop_order_by {
  current_value: order_by
  goal_value: order_by
}

"""aggregate stddev_samp on columns"""
type causes_stddev_samp_fields {
  current_value: Float
  goal_value: Float
}

"""
order by stddev_samp() on columns of table "causes"
"""
input causes_stddev_samp_order_by {
  current_value: order_by
  goal_value: order_by
}

"""
Streaming cursor of the table "causes"
"""
input causes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: causes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input causes_stream_cursor_value_input {
  category: String
  cover_img_url: String
  created_at: timestamptz
  created_by: uuid
  current_value: Int
  deleted_at: timestamptz
  description: String
  end_date: timestamptz
  goal_type: String
  goal_value: Int
  id: uuid
  location: String
  neighborhood_id: uuid
  start_date: timestamptz

  """'ongoing', 'active', 'completed', 'cancelled'"""
  status: String
  tags: [String!]
  title: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type causes_sum_fields {
  current_value: Int
  goal_value: Int
}

"""
order by sum() on columns of table "causes"
"""
input causes_sum_order_by {
  current_value: order_by
  goal_value: order_by
}

"""
update columns of table "causes"
"""
enum causes_update_column {
  """column name"""
  category

  """column name"""
  cover_img_url

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  current_value

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  end_date

  """column name"""
  goal_type

  """column name"""
  goal_value

  """column name"""
  id

  """column name"""
  location

  """column name"""
  neighborhood_id

  """column name"""
  start_date

  """column name"""
  status

  """column name"""
  tags

  """column name"""
  title

  """column name"""
  updated_at
}

input causes_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: causes_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: causes_set_input

  """filter the rows which have to be updated"""
  where: causes_bool_exp!
}

"""aggregate var_pop on columns"""
type causes_var_pop_fields {
  current_value: Float
  goal_value: Float
}

"""
order by var_pop() on columns of table "causes"
"""
input causes_var_pop_order_by {
  current_value: order_by
  goal_value: order_by
}

"""aggregate var_samp on columns"""
type causes_var_samp_fields {
  current_value: Float
  goal_value: Float
}

"""
order by var_samp() on columns of table "causes"
"""
input causes_var_samp_order_by {
  current_value: order_by
  goal_value: order_by
}

"""aggregate variance on columns"""
type causes_variance_fields {
  current_value: Float
  goal_value: Float
}

"""
order by variance() on columns of table "causes"
"""
input causes_variance_order_by {
  current_value: order_by
  goal_value: order_by
}

"""
columns and relationships of "connections"
"""
type connections {
  created_at: timestamptz

  """An object relationship"""
  receiver: users!
  receiver_id: uuid!

  """An object relationship"""
  sender: users!
  sender_id: uuid!

  """pending, accepted, rejected"""
  status: String
  updated_at: timestamptz
}

"""
aggregated selection of "connections"
"""
type connections_aggregate {
  aggregate: connections_aggregate_fields
  nodes: [connections!]!
}

input connections_aggregate_bool_exp {
  count: connections_aggregate_bool_exp_count
}

input connections_aggregate_bool_exp_count {
  arguments: [connections_select_column!]
  distinct: Boolean
  filter: connections_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "connections"
"""
type connections_aggregate_fields {
  count(columns: [connections_select_column!], distinct: Boolean): Int!
  max: connections_max_fields
  min: connections_min_fields
}

"""
order by aggregate values of table "connections"
"""
input connections_aggregate_order_by {
  count: order_by
  max: connections_max_order_by
  min: connections_min_order_by
}

"""
input type for inserting array relation for remote table "connections"
"""
input connections_arr_rel_insert_input {
  data: [connections_insert_input!]!

  """upsert condition"""
  on_conflict: connections_on_conflict
}

"""
Boolean expression to filter rows from the table "connections". All fields are combined with a logical 'AND'.
"""
input connections_bool_exp {
  _and: [connections_bool_exp!]
  _not: connections_bool_exp
  _or: [connections_bool_exp!]
  created_at: timestamptz_comparison_exp
  receiver: users_bool_exp
  receiver_id: uuid_comparison_exp
  sender: users_bool_exp
  sender_id: uuid_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "connections"
"""
enum connections_constraint {
  """
  unique or primary key constraint on columns "receiver_id", "sender_id"
  """
  friends_pkey
}

"""
input type for inserting data into table "connections"
"""
input connections_insert_input {
  created_at: timestamptz
  receiver: users_obj_rel_insert_input
  receiver_id: uuid
  sender: users_obj_rel_insert_input
  sender_id: uuid

  """pending, accepted, rejected"""
  status: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type connections_max_fields {
  created_at: timestamptz
  receiver_id: uuid
  sender_id: uuid

  """pending, accepted, rejected"""
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "connections"
"""
input connections_max_order_by {
  created_at: order_by
  receiver_id: order_by
  sender_id: order_by

  """pending, accepted, rejected"""
  status: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type connections_min_fields {
  created_at: timestamptz
  receiver_id: uuid
  sender_id: uuid

  """pending, accepted, rejected"""
  status: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "connections"
"""
input connections_min_order_by {
  created_at: order_by
  receiver_id: order_by
  sender_id: order_by

  """pending, accepted, rejected"""
  status: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "connections"
"""
type connections_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [connections!]!
}

"""
on_conflict condition type for table "connections"
"""
input connections_on_conflict {
  constraint: connections_constraint!
  update_columns: [connections_update_column!]! = []
  where: connections_bool_exp
}

"""Ordering options when selecting data from "connections"."""
input connections_order_by {
  created_at: order_by
  receiver: users_order_by
  receiver_id: order_by
  sender: users_order_by
  sender_id: order_by
  status: order_by
  updated_at: order_by
}

"""primary key columns input for table: connections"""
input connections_pk_columns_input {
  receiver_id: uuid!
  sender_id: uuid!
}

"""
select columns of table "connections"
"""
enum connections_select_column {
  """column name"""
  created_at

  """column name"""
  receiver_id

  """column name"""
  sender_id

  """column name"""
  status

  """column name"""
  updated_at
}

"""
input type for updating data in table "connections"
"""
input connections_set_input {
  created_at: timestamptz
  receiver_id: uuid
  sender_id: uuid

  """pending, accepted, rejected"""
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "connections"
"""
input connections_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: connections_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input connections_stream_cursor_value_input {
  created_at: timestamptz
  receiver_id: uuid
  sender_id: uuid

  """pending, accepted, rejected"""
  status: String
  updated_at: timestamptz
}

"""
update columns of table "connections"
"""
enum connections_update_column {
  """column name"""
  created_at

  """column name"""
  receiver_id

  """column name"""
  sender_id

  """column name"""
  status

  """column name"""
  updated_at
}

input connections_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: connections_set_input

  """filter the rows which have to be updated"""
  where: connections_bool_exp!
}

"""
columns and relationships of "conversation_participants"
"""
type conversation_participants {
  conversation_id: uuid!
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "conversation_participants"
"""
type conversation_participants_aggregate {
  aggregate: conversation_participants_aggregate_fields
  nodes: [conversation_participants!]!
}

input conversation_participants_aggregate_bool_exp {
  count: conversation_participants_aggregate_bool_exp_count
}

input conversation_participants_aggregate_bool_exp_count {
  arguments: [conversation_participants_select_column!]
  distinct: Boolean
  filter: conversation_participants_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "conversation_participants"
"""
type conversation_participants_aggregate_fields {
  avg: conversation_participants_avg_fields
  count(columns: [conversation_participants_select_column!], distinct: Boolean): Int!
  max: conversation_participants_max_fields
  min: conversation_participants_min_fields
  stddev: conversation_participants_stddev_fields
  stddev_pop: conversation_participants_stddev_pop_fields
  stddev_samp: conversation_participants_stddev_samp_fields
  sum: conversation_participants_sum_fields
  var_pop: conversation_participants_var_pop_fields
  var_samp: conversation_participants_var_samp_fields
  variance: conversation_participants_variance_fields
}

"""
order by aggregate values of table "conversation_participants"
"""
input conversation_participants_aggregate_order_by {
  avg: conversation_participants_avg_order_by
  count: order_by
  max: conversation_participants_max_order_by
  min: conversation_participants_min_order_by
  stddev: conversation_participants_stddev_order_by
  stddev_pop: conversation_participants_stddev_pop_order_by
  stddev_samp: conversation_participants_stddev_samp_order_by
  sum: conversation_participants_sum_order_by
  var_pop: conversation_participants_var_pop_order_by
  var_samp: conversation_participants_var_samp_order_by
  variance: conversation_participants_variance_order_by
}

"""
input type for inserting array relation for remote table "conversation_participants"
"""
input conversation_participants_arr_rel_insert_input {
  data: [conversation_participants_insert_input!]!

  """upsert condition"""
  on_conflict: conversation_participants_on_conflict
}

"""aggregate avg on columns"""
type conversation_participants_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "conversation_participants"
"""
input conversation_participants_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "conversation_participants". All fields are combined with a logical 'AND'.
"""
input conversation_participants_bool_exp {
  _and: [conversation_participants_bool_exp!]
  _not: conversation_participants_bool_exp
  _or: [conversation_participants_bool_exp!]
  conversation_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "conversation_participants"
"""
enum conversation_participants_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  conversation_participants_pkey

  """
  unique or primary key constraint on columns "user_id", "conversation_id"
  """
  conversation_participants_user_id_conversation_id_key
}

"""
input type for incrementing numeric columns in table "conversation_participants"
"""
input conversation_participants_inc_input {
  id: bigint
}

"""
input type for inserting data into table "conversation_participants"
"""
input conversation_participants_insert_input {
  conversation_id: uuid
  created_at: timestamptz
  id: bigint
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type conversation_participants_max_fields {
  conversation_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""
order by max() on columns of table "conversation_participants"
"""
input conversation_participants_max_order_by {
  conversation_id: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type conversation_participants_min_fields {
  conversation_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""
order by min() on columns of table "conversation_participants"
"""
input conversation_participants_min_order_by {
  conversation_id: order_by
  created_at: order_by
  id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "conversation_participants"
"""
type conversation_participants_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conversation_participants!]!
}

"""
on_conflict condition type for table "conversation_participants"
"""
input conversation_participants_on_conflict {
  constraint: conversation_participants_constraint!
  update_columns: [conversation_participants_update_column!]! = []
  where: conversation_participants_bool_exp
}

"""Ordering options when selecting data from "conversation_participants"."""
input conversation_participants_order_by {
  conversation_id: order_by
  created_at: order_by
  id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: conversation_participants"""
input conversation_participants_pk_columns_input {
  id: bigint!
}

"""
select columns of table "conversation_participants"
"""
enum conversation_participants_select_column {
  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  user_id
}

"""
input type for updating data in table "conversation_participants"
"""
input conversation_participants_set_input {
  conversation_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""aggregate stddev on columns"""
type conversation_participants_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "conversation_participants"
"""
input conversation_participants_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type conversation_participants_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "conversation_participants"
"""
input conversation_participants_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type conversation_participants_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "conversation_participants"
"""
input conversation_participants_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "conversation_participants"
"""
input conversation_participants_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conversation_participants_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conversation_participants_stream_cursor_value_input {
  conversation_id: uuid
  created_at: timestamptz
  id: bigint
  user_id: uuid
}

"""aggregate sum on columns"""
type conversation_participants_sum_fields {
  id: bigint
}

"""
order by sum() on columns of table "conversation_participants"
"""
input conversation_participants_sum_order_by {
  id: order_by
}

"""
update columns of table "conversation_participants"
"""
enum conversation_participants_update_column {
  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  user_id
}

input conversation_participants_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conversation_participants_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conversation_participants_set_input

  """filter the rows which have to be updated"""
  where: conversation_participants_bool_exp!
}

"""aggregate var_pop on columns"""
type conversation_participants_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "conversation_participants"
"""
input conversation_participants_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type conversation_participants_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "conversation_participants"
"""
input conversation_participants_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type conversation_participants_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "conversation_participants"
"""
input conversation_participants_variance_order_by {
  id: order_by
}

"""
columns and relationships of "conversations"
"""
type conversations {
  created_at: timestamptz!
  created_by: uuid
  id: Int!
  image_url: String

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!
  name: String
  type: String

  """An object relationship"""
  user: users!
  user1: uuid!
  user2: uuid!

  """An object relationship"""
  userByUser2: users!
}

"""
aggregated selection of "conversations"
"""
type conversations_aggregate {
  aggregate: conversations_aggregate_fields
  nodes: [conversations!]!
}

input conversations_aggregate_bool_exp {
  count: conversations_aggregate_bool_exp_count
}

input conversations_aggregate_bool_exp_count {
  arguments: [conversations_select_column!]
  distinct: Boolean
  filter: conversations_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "conversations"
"""
type conversations_aggregate_fields {
  avg: conversations_avg_fields
  count(columns: [conversations_select_column!], distinct: Boolean): Int!
  max: conversations_max_fields
  min: conversations_min_fields
  stddev: conversations_stddev_fields
  stddev_pop: conversations_stddev_pop_fields
  stddev_samp: conversations_stddev_samp_fields
  sum: conversations_sum_fields
  var_pop: conversations_var_pop_fields
  var_samp: conversations_var_samp_fields
  variance: conversations_variance_fields
}

"""
order by aggregate values of table "conversations"
"""
input conversations_aggregate_order_by {
  avg: conversations_avg_order_by
  count: order_by
  max: conversations_max_order_by
  min: conversations_min_order_by
  stddev: conversations_stddev_order_by
  stddev_pop: conversations_stddev_pop_order_by
  stddev_samp: conversations_stddev_samp_order_by
  sum: conversations_sum_order_by
  var_pop: conversations_var_pop_order_by
  var_samp: conversations_var_samp_order_by
  variance: conversations_variance_order_by
}

"""
input type for inserting array relation for remote table "conversations"
"""
input conversations_arr_rel_insert_input {
  data: [conversations_insert_input!]!

  """upsert condition"""
  on_conflict: conversations_on_conflict
}

"""aggregate avg on columns"""
type conversations_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "conversations"
"""
input conversations_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "conversations". All fields are combined with a logical 'AND'.
"""
input conversations_bool_exp {
  _and: [conversations_bool_exp!]
  _not: conversations_bool_exp
  _or: [conversations_bool_exp!]
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  id: Int_comparison_exp
  image_url: String_comparison_exp
  messages: messages_bool_exp
  messages_aggregate: messages_aggregate_bool_exp
  name: String_comparison_exp
  type: String_comparison_exp
  user: users_bool_exp
  user1: uuid_comparison_exp
  user2: uuid_comparison_exp
  userByUser2: users_bool_exp
}

"""
unique or primary key constraints on table "conversations"
"""
enum conversations_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  conversations_pkey
}

"""
input type for incrementing numeric columns in table "conversations"
"""
input conversations_inc_input {
  id: Int
}

"""
input type for inserting data into table "conversations"
"""
input conversations_insert_input {
  created_at: timestamptz
  created_by: uuid
  id: Int
  image_url: String
  messages: messages_arr_rel_insert_input
  name: String
  type: String
  user: users_obj_rel_insert_input
  user1: uuid
  user2: uuid
  userByUser2: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type conversations_max_fields {
  created_at: timestamptz
  created_by: uuid
  id: Int
  image_url: String
  name: String
  type: String
  user1: uuid
  user2: uuid
}

"""
order by max() on columns of table "conversations"
"""
input conversations_max_order_by {
  created_at: order_by
  created_by: order_by
  id: order_by
  image_url: order_by
  name: order_by
  type: order_by
  user1: order_by
  user2: order_by
}

"""aggregate min on columns"""
type conversations_min_fields {
  created_at: timestamptz
  created_by: uuid
  id: Int
  image_url: String
  name: String
  type: String
  user1: uuid
  user2: uuid
}

"""
order by min() on columns of table "conversations"
"""
input conversations_min_order_by {
  created_at: order_by
  created_by: order_by
  id: order_by
  image_url: order_by
  name: order_by
  type: order_by
  user1: order_by
  user2: order_by
}

"""
response of any mutation on the table "conversations"
"""
type conversations_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [conversations!]!
}

"""
input type for inserting object relation for remote table "conversations"
"""
input conversations_obj_rel_insert_input {
  data: conversations_insert_input!

  """upsert condition"""
  on_conflict: conversations_on_conflict
}

"""
on_conflict condition type for table "conversations"
"""
input conversations_on_conflict {
  constraint: conversations_constraint!
  update_columns: [conversations_update_column!]! = []
  where: conversations_bool_exp
}

"""Ordering options when selecting data from "conversations"."""
input conversations_order_by {
  created_at: order_by
  created_by: order_by
  id: order_by
  image_url: order_by
  messages_aggregate: messages_aggregate_order_by
  name: order_by
  type: order_by
  user: users_order_by
  user1: order_by
  user2: order_by
  userByUser2: users_order_by
}

"""primary key columns input for table: conversations"""
input conversations_pk_columns_input {
  id: Int!
}

"""
select columns of table "conversations"
"""
enum conversations_select_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  name

  """column name"""
  type

  """column name"""
  user1

  """column name"""
  user2
}

"""
input type for updating data in table "conversations"
"""
input conversations_set_input {
  created_at: timestamptz
  created_by: uuid
  id: Int
  image_url: String
  name: String
  type: String
  user1: uuid
  user2: uuid
}

"""aggregate stddev on columns"""
type conversations_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "conversations"
"""
input conversations_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type conversations_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "conversations"
"""
input conversations_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type conversations_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "conversations"
"""
input conversations_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "conversations"
"""
input conversations_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: conversations_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input conversations_stream_cursor_value_input {
  created_at: timestamptz
  created_by: uuid
  id: Int
  image_url: String
  name: String
  type: String
  user1: uuid
  user2: uuid
}

"""aggregate sum on columns"""
type conversations_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "conversations"
"""
input conversations_sum_order_by {
  id: order_by
}

"""
update columns of table "conversations"
"""
enum conversations_update_column {
  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  id

  """column name"""
  image_url

  """column name"""
  name

  """column name"""
  type

  """column name"""
  user1

  """column name"""
  user2
}

input conversations_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: conversations_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: conversations_set_input

  """filter the rows which have to be updated"""
  where: conversations_bool_exp!
}

"""aggregate var_pop on columns"""
type conversations_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "conversations"
"""
input conversations_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type conversations_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "conversations"
"""
input conversations_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type conversations_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "conversations"
"""
input conversations_variance_order_by {
  id: order_by
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar date

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input date_comparison_exp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _is_null: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

input insert_or_get_conversation_args {
  _user1: uuid
  _user2: uuid
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "messages"
"""
type messages {
  """An array relationship"""
  attachments(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An aggregate relationship"""
  attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): attachments_aggregate!
  content: String

  """An object relationship"""
  conversation: conversations
  conversation_id: Int
  created_at: timestamp
  id: bigint!
  media_url: String
  message_type: String
  reply_to_message_id: bigint
  sender_id: uuid
  status: String

  """An object relationship"""
  userBySenderId: users
}

"""
aggregated selection of "messages"
"""
type messages_aggregate {
  aggregate: messages_aggregate_fields
  nodes: [messages!]!
}

input messages_aggregate_bool_exp {
  count: messages_aggregate_bool_exp_count
}

input messages_aggregate_bool_exp_count {
  arguments: [messages_select_column!]
  distinct: Boolean
  filter: messages_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "messages"
"""
type messages_aggregate_fields {
  avg: messages_avg_fields
  count(columns: [messages_select_column!], distinct: Boolean): Int!
  max: messages_max_fields
  min: messages_min_fields
  stddev: messages_stddev_fields
  stddev_pop: messages_stddev_pop_fields
  stddev_samp: messages_stddev_samp_fields
  sum: messages_sum_fields
  var_pop: messages_var_pop_fields
  var_samp: messages_var_samp_fields
  variance: messages_variance_fields
}

"""
order by aggregate values of table "messages"
"""
input messages_aggregate_order_by {
  avg: messages_avg_order_by
  count: order_by
  max: messages_max_order_by
  min: messages_min_order_by
  stddev: messages_stddev_order_by
  stddev_pop: messages_stddev_pop_order_by
  stddev_samp: messages_stddev_samp_order_by
  sum: messages_sum_order_by
  var_pop: messages_var_pop_order_by
  var_samp: messages_var_samp_order_by
  variance: messages_variance_order_by
}

"""
input type for inserting array relation for remote table "messages"
"""
input messages_arr_rel_insert_input {
  data: [messages_insert_input!]!

  """upsert condition"""
  on_conflict: messages_on_conflict
}

"""aggregate avg on columns"""
type messages_avg_fields {
  conversation_id: Float
  id: Float
  reply_to_message_id: Float
}

"""
order by avg() on columns of table "messages"
"""
input messages_avg_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""
Boolean expression to filter rows from the table "messages". All fields are combined with a logical 'AND'.
"""
input messages_bool_exp {
  _and: [messages_bool_exp!]
  _not: messages_bool_exp
  _or: [messages_bool_exp!]
  attachments: attachments_bool_exp
  attachments_aggregate: attachments_aggregate_bool_exp
  content: String_comparison_exp
  conversation: conversations_bool_exp
  conversation_id: Int_comparison_exp
  created_at: timestamp_comparison_exp
  id: bigint_comparison_exp
  media_url: String_comparison_exp
  message_type: String_comparison_exp
  reply_to_message_id: bigint_comparison_exp
  sender_id: uuid_comparison_exp
  status: String_comparison_exp
  userBySenderId: users_bool_exp
}

"""
unique or primary key constraints on table "messages"
"""
enum messages_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  messages_pkey
}

"""
input type for incrementing numeric columns in table "messages"
"""
input messages_inc_input {
  conversation_id: Int
  id: bigint
  reply_to_message_id: bigint
}

"""
input type for inserting data into table "messages"
"""
input messages_insert_input {
  attachments: attachments_arr_rel_insert_input
  content: String
  conversation: conversations_obj_rel_insert_input
  conversation_id: Int
  created_at: timestamp
  id: bigint
  media_url: String
  message_type: String
  reply_to_message_id: bigint
  sender_id: uuid
  status: String
  userBySenderId: users_obj_rel_insert_input
}

"""aggregate max on columns"""
type messages_max_fields {
  content: String
  conversation_id: Int
  created_at: timestamp
  id: bigint
  media_url: String
  message_type: String
  reply_to_message_id: bigint
  sender_id: uuid
  status: String
}

"""
order by max() on columns of table "messages"
"""
input messages_max_order_by {
  content: order_by
  conversation_id: order_by
  created_at: order_by
  id: order_by
  media_url: order_by
  message_type: order_by
  reply_to_message_id: order_by
  sender_id: order_by
  status: order_by
}

"""aggregate min on columns"""
type messages_min_fields {
  content: String
  conversation_id: Int
  created_at: timestamp
  id: bigint
  media_url: String
  message_type: String
  reply_to_message_id: bigint
  sender_id: uuid
  status: String
}

"""
order by min() on columns of table "messages"
"""
input messages_min_order_by {
  content: order_by
  conversation_id: order_by
  created_at: order_by
  id: order_by
  media_url: order_by
  message_type: order_by
  reply_to_message_id: order_by
  sender_id: order_by
  status: order_by
}

"""
response of any mutation on the table "messages"
"""
type messages_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [messages!]!
}

"""
input type for inserting object relation for remote table "messages"
"""
input messages_obj_rel_insert_input {
  data: messages_insert_input!

  """upsert condition"""
  on_conflict: messages_on_conflict
}

"""
on_conflict condition type for table "messages"
"""
input messages_on_conflict {
  constraint: messages_constraint!
  update_columns: [messages_update_column!]! = []
  where: messages_bool_exp
}

"""Ordering options when selecting data from "messages"."""
input messages_order_by {
  attachments_aggregate: attachments_aggregate_order_by
  content: order_by
  conversation: conversations_order_by
  conversation_id: order_by
  created_at: order_by
  id: order_by
  media_url: order_by
  message_type: order_by
  reply_to_message_id: order_by
  sender_id: order_by
  status: order_by
  userBySenderId: users_order_by
}

"""primary key columns input for table: messages"""
input messages_pk_columns_input {
  id: bigint!
}

"""
select columns of table "messages"
"""
enum messages_select_column {
  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  media_url

  """column name"""
  message_type

  """column name"""
  reply_to_message_id

  """column name"""
  sender_id

  """column name"""
  status
}

"""
input type for updating data in table "messages"
"""
input messages_set_input {
  content: String
  conversation_id: Int
  created_at: timestamp
  id: bigint
  media_url: String
  message_type: String
  reply_to_message_id: bigint
  sender_id: uuid
  status: String
}

"""aggregate stddev on columns"""
type messages_stddev_fields {
  conversation_id: Float
  id: Float
  reply_to_message_id: Float
}

"""
order by stddev() on columns of table "messages"
"""
input messages_stddev_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""aggregate stddev_pop on columns"""
type messages_stddev_pop_fields {
  conversation_id: Float
  id: Float
  reply_to_message_id: Float
}

"""
order by stddev_pop() on columns of table "messages"
"""
input messages_stddev_pop_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""aggregate stddev_samp on columns"""
type messages_stddev_samp_fields {
  conversation_id: Float
  id: Float
  reply_to_message_id: Float
}

"""
order by stddev_samp() on columns of table "messages"
"""
input messages_stddev_samp_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""
Streaming cursor of the table "messages"
"""
input messages_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: messages_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input messages_stream_cursor_value_input {
  content: String
  conversation_id: Int
  created_at: timestamp
  id: bigint
  media_url: String
  message_type: String
  reply_to_message_id: bigint
  sender_id: uuid
  status: String
}

"""aggregate sum on columns"""
type messages_sum_fields {
  conversation_id: Int
  id: bigint
  reply_to_message_id: bigint
}

"""
order by sum() on columns of table "messages"
"""
input messages_sum_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""
update columns of table "messages"
"""
enum messages_update_column {
  """column name"""
  content

  """column name"""
  conversation_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  media_url

  """column name"""
  message_type

  """column name"""
  reply_to_message_id

  """column name"""
  sender_id

  """column name"""
  status
}

input messages_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: messages_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: messages_set_input

  """filter the rows which have to be updated"""
  where: messages_bool_exp!
}

"""aggregate var_pop on columns"""
type messages_var_pop_fields {
  conversation_id: Float
  id: Float
  reply_to_message_id: Float
}

"""
order by var_pop() on columns of table "messages"
"""
input messages_var_pop_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""aggregate var_samp on columns"""
type messages_var_samp_fields {
  conversation_id: Float
  id: Float
  reply_to_message_id: Float
}

"""
order by var_samp() on columns of table "messages"
"""
input messages_var_samp_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""aggregate variance on columns"""
type messages_variance_fields {
  conversation_id: Float
  id: Float
  reply_to_message_id: Float
}

"""
order by variance() on columns of table "messages"
"""
input messages_variance_order_by {
  conversation_id: order_by
  id: order_by
  reply_to_message_id: order_by
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "accounts"
  """
  delete_accounts(
    """filter the rows which have to be deleted"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  delete single row from the table: "accounts"
  """
  delete_accounts_by_pk(id: uuid!): accounts

  """
  delete data from the table: "attachments"
  """
  delete_attachments(
    """filter the rows which have to be deleted"""
    where: attachments_bool_exp!
  ): attachments_mutation_response

  """
  delete single row from the table: "attachments"
  """
  delete_attachments_by_pk(id: Int!): attachments

  """
  delete data from the table: "bookmarks"
  """
  delete_bookmarks(
    """filter the rows which have to be deleted"""
    where: bookmarks_bool_exp!
  ): bookmarks_mutation_response

  """
  delete single row from the table: "bookmarks"
  """
  delete_bookmarks_by_pk(post_id: Int!, user_id: uuid!): bookmarks

  """
  delete data from the table: "cause_supporters"
  """
  delete_cause_supporters(
    """filter the rows which have to be deleted"""
    where: cause_supporters_bool_exp!
  ): cause_supporters_mutation_response

  """
  delete single row from the table: "cause_supporters"
  """
  delete_cause_supporters_by_pk(id: bigint!): cause_supporters

  """
  delete data from the table: "causes"
  """
  delete_causes(
    """filter the rows which have to be deleted"""
    where: causes_bool_exp!
  ): causes_mutation_response

  """
  delete single row from the table: "causes"
  """
  delete_causes_by_pk(id: uuid!): causes

  """
  delete data from the table: "connections"
  """
  delete_connections(
    """filter the rows which have to be deleted"""
    where: connections_bool_exp!
  ): connections_mutation_response

  """
  delete single row from the table: "connections"
  """
  delete_connections_by_pk(receiver_id: uuid!, sender_id: uuid!): connections

  """
  delete data from the table: "conversation_participants"
  """
  delete_conversation_participants(
    """filter the rows which have to be deleted"""
    where: conversation_participants_bool_exp!
  ): conversation_participants_mutation_response

  """
  delete single row from the table: "conversation_participants"
  """
  delete_conversation_participants_by_pk(id: bigint!): conversation_participants

  """
  delete data from the table: "conversations"
  """
  delete_conversations(
    """filter the rows which have to be deleted"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  delete single row from the table: "conversations"
  """
  delete_conversations_by_pk(id: Int!): conversations

  """
  delete data from the table: "messages"
  """
  delete_messages(
    """filter the rows which have to be deleted"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  delete single row from the table: "messages"
  """
  delete_messages_by_pk(id: bigint!): messages

  """
  delete data from the table: "neighborhood_followers"
  """
  delete_neighborhood_followers(
    """filter the rows which have to be deleted"""
    where: neighborhood_followers_bool_exp!
  ): neighborhood_followers_mutation_response

  """
  delete single row from the table: "neighborhood_followers"
  """
  delete_neighborhood_followers_by_pk(id: bigint!): neighborhood_followers

  """
  delete data from the table: "neighborhoods"
  """
  delete_neighborhoods(
    """filter the rows which have to be deleted"""
    where: neighborhoods_bool_exp!
  ): neighborhoods_mutation_response

  """
  delete single row from the table: "neighborhoods"
  """
  delete_neighborhoods_by_pk(id: uuid!): neighborhoods

  """
  delete data from the table: "notifications"
  """
  delete_notifications(
    """filter the rows which have to be deleted"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  delete single row from the table: "notifications"
  """
  delete_notifications_by_pk(id: Int!, recipient_id: uuid!): notifications

  """
  delete data from the table: "post_comments"
  """
  delete_post_comments(
    """filter the rows which have to be deleted"""
    where: post_comments_bool_exp!
  ): post_comments_mutation_response

  """
  delete single row from the table: "post_comments"
  """
  delete_post_comments_by_pk(id: bigint!, post_id: bigint!): post_comments

  """
  delete data from the table: "post_reactions"
  """
  delete_post_reactions(
    """filter the rows which have to be deleted"""
    where: post_reactions_bool_exp!
  ): post_reactions_mutation_response

  """
  delete single row from the table: "post_reactions"
  """
  delete_post_reactions_by_pk(post_id: Int!, user_id: uuid!): post_reactions

  """
  delete data from the table: "post_shares"
  """
  delete_post_shares(
    """filter the rows which have to be deleted"""
    where: post_shares_bool_exp!
  ): post_shares_mutation_response

  """
  delete single row from the table: "post_shares"
  """
  delete_post_shares_by_pk(id: bigint!, post_id: bigint!): post_shares

  """
  delete data from the table: "posts"
  """
  delete_posts(
    """filter the rows which have to be deleted"""
    where: posts_bool_exp!
  ): posts_mutation_response

  """
  delete single row from the table: "posts"
  """
  delete_posts_by_pk(id: bigint!): posts

  """
  delete data from the table: "profiles"
  """
  delete_profiles(
    """filter the rows which have to be deleted"""
    where: profiles_bool_exp!
  ): profiles_mutation_response

  """
  delete single row from the table: "profiles"
  """
  delete_profiles_by_pk(user_id: uuid!): profiles

  """
  delete data from the table: "sessions"
  """
  delete_sessions(
    """filter the rows which have to be deleted"""
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  delete single row from the table: "sessions"
  """
  delete_sessions_by_pk(id: uuid!): sessions

  """
  delete data from the table: "user_neighborhood"
  """
  delete_user_neighborhood(
    """filter the rows which have to be deleted"""
    where: user_neighborhood_bool_exp!
  ): user_neighborhood_mutation_response

  """
  delete single row from the table: "user_neighborhood"
  """
  delete_user_neighborhood_by_pk(user_id: uuid!): user_neighborhood

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  delete data from the table: "verification_tokens"
  """
  delete_verification_tokens(
    """filter the rows which have to be deleted"""
    where: verification_tokens_bool_exp!
  ): verification_tokens_mutation_response

  """
  delete single row from the table: "verification_tokens"
  """
  delete_verification_tokens_by_pk(token: String!): verification_tokens

  """
  delete data from the table: "volunteers"
  """
  delete_volunteers(
    """filter the rows which have to be deleted"""
    where: volunteers_bool_exp!
  ): volunteers_mutation_response

  """
  delete single row from the table: "volunteers"
  """
  delete_volunteers_by_pk(id: Int!): volunteers

  """
  insert data into the table: "accounts"
  """
  insert_accounts(
    """the rows to be inserted"""
    objects: [accounts_insert_input!]!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts_mutation_response

  """
  insert a single row into the table: "accounts"
  """
  insert_accounts_one(
    """the row to be inserted"""
    object: accounts_insert_input!

    """upsert condition"""
    on_conflict: accounts_on_conflict
  ): accounts

  """
  insert data into the table: "attachments"
  """
  insert_attachments(
    """the rows to be inserted"""
    objects: [attachments_insert_input!]!

    """upsert condition"""
    on_conflict: attachments_on_conflict
  ): attachments_mutation_response

  """
  insert a single row into the table: "attachments"
  """
  insert_attachments_one(
    """the row to be inserted"""
    object: attachments_insert_input!

    """upsert condition"""
    on_conflict: attachments_on_conflict
  ): attachments

  """
  insert data into the table: "bookmarks"
  """
  insert_bookmarks(
    """the rows to be inserted"""
    objects: [bookmarks_insert_input!]!

    """upsert condition"""
    on_conflict: bookmarks_on_conflict
  ): bookmarks_mutation_response

  """
  insert a single row into the table: "bookmarks"
  """
  insert_bookmarks_one(
    """the row to be inserted"""
    object: bookmarks_insert_input!

    """upsert condition"""
    on_conflict: bookmarks_on_conflict
  ): bookmarks

  """
  insert data into the table: "cause_supporters"
  """
  insert_cause_supporters(
    """the rows to be inserted"""
    objects: [cause_supporters_insert_input!]!

    """upsert condition"""
    on_conflict: cause_supporters_on_conflict
  ): cause_supporters_mutation_response

  """
  insert a single row into the table: "cause_supporters"
  """
  insert_cause_supporters_one(
    """the row to be inserted"""
    object: cause_supporters_insert_input!

    """upsert condition"""
    on_conflict: cause_supporters_on_conflict
  ): cause_supporters

  """
  insert data into the table: "causes"
  """
  insert_causes(
    """the rows to be inserted"""
    objects: [causes_insert_input!]!

    """upsert condition"""
    on_conflict: causes_on_conflict
  ): causes_mutation_response

  """
  insert a single row into the table: "causes"
  """
  insert_causes_one(
    """the row to be inserted"""
    object: causes_insert_input!

    """upsert condition"""
    on_conflict: causes_on_conflict
  ): causes

  """
  insert data into the table: "connections"
  """
  insert_connections(
    """the rows to be inserted"""
    objects: [connections_insert_input!]!

    """upsert condition"""
    on_conflict: connections_on_conflict
  ): connections_mutation_response

  """
  insert a single row into the table: "connections"
  """
  insert_connections_one(
    """the row to be inserted"""
    object: connections_insert_input!

    """upsert condition"""
    on_conflict: connections_on_conflict
  ): connections

  """
  insert data into the table: "conversation_participants"
  """
  insert_conversation_participants(
    """the rows to be inserted"""
    objects: [conversation_participants_insert_input!]!

    """upsert condition"""
    on_conflict: conversation_participants_on_conflict
  ): conversation_participants_mutation_response

  """
  insert a single row into the table: "conversation_participants"
  """
  insert_conversation_participants_one(
    """the row to be inserted"""
    object: conversation_participants_insert_input!

    """upsert condition"""
    on_conflict: conversation_participants_on_conflict
  ): conversation_participants

  """
  insert data into the table: "conversations"
  """
  insert_conversations(
    """the rows to be inserted"""
    objects: [conversations_insert_input!]!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations_mutation_response

  """
  insert a single row into the table: "conversations"
  """
  insert_conversations_one(
    """the row to be inserted"""
    object: conversations_insert_input!

    """upsert condition"""
    on_conflict: conversations_on_conflict
  ): conversations

  """
  insert data into the table: "messages"
  """
  insert_messages(
    """the rows to be inserted"""
    objects: [messages_insert_input!]!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages_mutation_response

  """
  insert a single row into the table: "messages"
  """
  insert_messages_one(
    """the row to be inserted"""
    object: messages_insert_input!

    """upsert condition"""
    on_conflict: messages_on_conflict
  ): messages

  """
  insert data into the table: "neighborhood_followers"
  """
  insert_neighborhood_followers(
    """the rows to be inserted"""
    objects: [neighborhood_followers_insert_input!]!

    """upsert condition"""
    on_conflict: neighborhood_followers_on_conflict
  ): neighborhood_followers_mutation_response

  """
  insert a single row into the table: "neighborhood_followers"
  """
  insert_neighborhood_followers_one(
    """the row to be inserted"""
    object: neighborhood_followers_insert_input!

    """upsert condition"""
    on_conflict: neighborhood_followers_on_conflict
  ): neighborhood_followers

  """
  insert data into the table: "neighborhoods"
  """
  insert_neighborhoods(
    """the rows to be inserted"""
    objects: [neighborhoods_insert_input!]!

    """upsert condition"""
    on_conflict: neighborhoods_on_conflict
  ): neighborhoods_mutation_response

  """
  insert a single row into the table: "neighborhoods"
  """
  insert_neighborhoods_one(
    """the row to be inserted"""
    object: neighborhoods_insert_input!

    """upsert condition"""
    on_conflict: neighborhoods_on_conflict
  ): neighborhoods

  """
  insert data into the table: "notifications"
  """
  insert_notifications(
    """the rows to be inserted"""
    objects: [notifications_insert_input!]!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications_mutation_response

  """
  insert a single row into the table: "notifications"
  """
  insert_notifications_one(
    """the row to be inserted"""
    object: notifications_insert_input!

    """upsert condition"""
    on_conflict: notifications_on_conflict
  ): notifications

  """
  execute VOLATILE function "insert_or_get_conversation" which returns "conversations"
  """
  insert_or_get_conversation(
    """
    input parameters for function "insert_or_get_conversation"
    """
    args: insert_or_get_conversation_args!

    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """
  insert data into the table: "post_comments"
  """
  insert_post_comments(
    """the rows to be inserted"""
    objects: [post_comments_insert_input!]!

    """upsert condition"""
    on_conflict: post_comments_on_conflict
  ): post_comments_mutation_response

  """
  insert a single row into the table: "post_comments"
  """
  insert_post_comments_one(
    """the row to be inserted"""
    object: post_comments_insert_input!

    """upsert condition"""
    on_conflict: post_comments_on_conflict
  ): post_comments

  """
  insert data into the table: "post_reactions"
  """
  insert_post_reactions(
    """the rows to be inserted"""
    objects: [post_reactions_insert_input!]!

    """upsert condition"""
    on_conflict: post_reactions_on_conflict
  ): post_reactions_mutation_response

  """
  insert a single row into the table: "post_reactions"
  """
  insert_post_reactions_one(
    """the row to be inserted"""
    object: post_reactions_insert_input!

    """upsert condition"""
    on_conflict: post_reactions_on_conflict
  ): post_reactions

  """
  insert data into the table: "post_shares"
  """
  insert_post_shares(
    """the rows to be inserted"""
    objects: [post_shares_insert_input!]!

    """upsert condition"""
    on_conflict: post_shares_on_conflict
  ): post_shares_mutation_response

  """
  insert a single row into the table: "post_shares"
  """
  insert_post_shares_one(
    """the row to be inserted"""
    object: post_shares_insert_input!

    """upsert condition"""
    on_conflict: post_shares_on_conflict
  ): post_shares

  """
  insert data into the table: "posts"
  """
  insert_posts(
    """the rows to be inserted"""
    objects: [posts_insert_input!]!

    """upsert condition"""
    on_conflict: posts_on_conflict
  ): posts_mutation_response

  """
  insert a single row into the table: "posts"
  """
  insert_posts_one(
    """the row to be inserted"""
    object: posts_insert_input!

    """upsert condition"""
    on_conflict: posts_on_conflict
  ): posts

  """
  insert data into the table: "profiles"
  """
  insert_profiles(
    """the rows to be inserted"""
    objects: [profiles_insert_input!]!

    """upsert condition"""
    on_conflict: profiles_on_conflict
  ): profiles_mutation_response

  """
  insert a single row into the table: "profiles"
  """
  insert_profiles_one(
    """the row to be inserted"""
    object: profiles_insert_input!

    """upsert condition"""
    on_conflict: profiles_on_conflict
  ): profiles

  """
  insert data into the table: "sessions"
  """
  insert_sessions(
    """the rows to be inserted"""
    objects: [sessions_insert_input!]!

    """upsert condition"""
    on_conflict: sessions_on_conflict
  ): sessions_mutation_response

  """
  insert a single row into the table: "sessions"
  """
  insert_sessions_one(
    """the row to be inserted"""
    object: sessions_insert_input!

    """upsert condition"""
    on_conflict: sessions_on_conflict
  ): sessions

  """
  insert data into the table: "user_neighborhood"
  """
  insert_user_neighborhood(
    """the rows to be inserted"""
    objects: [user_neighborhood_insert_input!]!

    """upsert condition"""
    on_conflict: user_neighborhood_on_conflict
  ): user_neighborhood_mutation_response

  """
  insert a single row into the table: "user_neighborhood"
  """
  insert_user_neighborhood_one(
    """the row to be inserted"""
    object: user_neighborhood_insert_input!

    """upsert condition"""
    on_conflict: user_neighborhood_on_conflict
  ): user_neighborhood

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "verification_tokens"
  """
  insert_verification_tokens(
    """the rows to be inserted"""
    objects: [verification_tokens_insert_input!]!

    """upsert condition"""
    on_conflict: verification_tokens_on_conflict
  ): verification_tokens_mutation_response

  """
  insert a single row into the table: "verification_tokens"
  """
  insert_verification_tokens_one(
    """the row to be inserted"""
    object: verification_tokens_insert_input!

    """upsert condition"""
    on_conflict: verification_tokens_on_conflict
  ): verification_tokens

  """
  insert data into the table: "volunteers"
  """
  insert_volunteers(
    """the rows to be inserted"""
    objects: [volunteers_insert_input!]!

    """upsert condition"""
    on_conflict: volunteers_on_conflict
  ): volunteers_mutation_response

  """
  insert a single row into the table: "volunteers"
  """
  insert_volunteers_one(
    """the row to be inserted"""
    object: volunteers_insert_input!

    """upsert condition"""
    on_conflict: volunteers_on_conflict
  ): volunteers

  """
  update data of the table: "accounts"
  """
  update_accounts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input

    """filter the rows which have to be updated"""
    where: accounts_bool_exp!
  ): accounts_mutation_response

  """
  update single row of the table: "accounts"
  """
  update_accounts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: accounts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: accounts_set_input
    pk_columns: accounts_pk_columns_input!
  ): accounts

  """
  update multiples rows of table: "accounts"
  """
  update_accounts_many(
    """updates to execute, in order"""
    updates: [accounts_updates!]!
  ): [accounts_mutation_response]

  """
  update data of the table: "attachments"
  """
  update_attachments(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attachments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attachments_set_input

    """filter the rows which have to be updated"""
    where: attachments_bool_exp!
  ): attachments_mutation_response

  """
  update single row of the table: "attachments"
  """
  update_attachments_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: attachments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: attachments_set_input
    pk_columns: attachments_pk_columns_input!
  ): attachments

  """
  update multiples rows of table: "attachments"
  """
  update_attachments_many(
    """updates to execute, in order"""
    updates: [attachments_updates!]!
  ): [attachments_mutation_response]

  """
  update data of the table: "bookmarks"
  """
  update_bookmarks(
    """increments the numeric columns with given value of the filtered values"""
    _inc: bookmarks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookmarks_set_input

    """filter the rows which have to be updated"""
    where: bookmarks_bool_exp!
  ): bookmarks_mutation_response

  """
  update single row of the table: "bookmarks"
  """
  update_bookmarks_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: bookmarks_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bookmarks_set_input
    pk_columns: bookmarks_pk_columns_input!
  ): bookmarks

  """
  update multiples rows of table: "bookmarks"
  """
  update_bookmarks_many(
    """updates to execute, in order"""
    updates: [bookmarks_updates!]!
  ): [bookmarks_mutation_response]

  """
  update data of the table: "cause_supporters"
  """
  update_cause_supporters(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cause_supporters_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cause_supporters_set_input

    """filter the rows which have to be updated"""
    where: cause_supporters_bool_exp!
  ): cause_supporters_mutation_response

  """
  update single row of the table: "cause_supporters"
  """
  update_cause_supporters_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: cause_supporters_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: cause_supporters_set_input
    pk_columns: cause_supporters_pk_columns_input!
  ): cause_supporters

  """
  update multiples rows of table: "cause_supporters"
  """
  update_cause_supporters_many(
    """updates to execute, in order"""
    updates: [cause_supporters_updates!]!
  ): [cause_supporters_mutation_response]

  """
  update data of the table: "causes"
  """
  update_causes(
    """increments the numeric columns with given value of the filtered values"""
    _inc: causes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: causes_set_input

    """filter the rows which have to be updated"""
    where: causes_bool_exp!
  ): causes_mutation_response

  """
  update single row of the table: "causes"
  """
  update_causes_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: causes_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: causes_set_input
    pk_columns: causes_pk_columns_input!
  ): causes

  """
  update multiples rows of table: "causes"
  """
  update_causes_many(
    """updates to execute, in order"""
    updates: [causes_updates!]!
  ): [causes_mutation_response]

  """
  update data of the table: "connections"
  """
  update_connections(
    """sets the columns of the filtered rows to the given values"""
    _set: connections_set_input

    """filter the rows which have to be updated"""
    where: connections_bool_exp!
  ): connections_mutation_response

  """
  update single row of the table: "connections"
  """
  update_connections_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: connections_set_input
    pk_columns: connections_pk_columns_input!
  ): connections

  """
  update multiples rows of table: "connections"
  """
  update_connections_many(
    """updates to execute, in order"""
    updates: [connections_updates!]!
  ): [connections_mutation_response]

  """
  update data of the table: "conversation_participants"
  """
  update_conversation_participants(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conversation_participants_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversation_participants_set_input

    """filter the rows which have to be updated"""
    where: conversation_participants_bool_exp!
  ): conversation_participants_mutation_response

  """
  update single row of the table: "conversation_participants"
  """
  update_conversation_participants_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conversation_participants_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversation_participants_set_input
    pk_columns: conversation_participants_pk_columns_input!
  ): conversation_participants

  """
  update multiples rows of table: "conversation_participants"
  """
  update_conversation_participants_many(
    """updates to execute, in order"""
    updates: [conversation_participants_updates!]!
  ): [conversation_participants_mutation_response]

  """
  update data of the table: "conversations"
  """
  update_conversations(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conversations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input

    """filter the rows which have to be updated"""
    where: conversations_bool_exp!
  ): conversations_mutation_response

  """
  update single row of the table: "conversations"
  """
  update_conversations_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: conversations_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: conversations_set_input
    pk_columns: conversations_pk_columns_input!
  ): conversations

  """
  update multiples rows of table: "conversations"
  """
  update_conversations_many(
    """updates to execute, in order"""
    updates: [conversations_updates!]!
  ): [conversations_mutation_response]

  """
  update data of the table: "messages"
  """
  update_messages(
    """increments the numeric columns with given value of the filtered values"""
    _inc: messages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input

    """filter the rows which have to be updated"""
    where: messages_bool_exp!
  ): messages_mutation_response

  """
  update single row of the table: "messages"
  """
  update_messages_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: messages_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: messages_set_input
    pk_columns: messages_pk_columns_input!
  ): messages

  """
  update multiples rows of table: "messages"
  """
  update_messages_many(
    """updates to execute, in order"""
    updates: [messages_updates!]!
  ): [messages_mutation_response]

  """
  update data of the table: "neighborhood_followers"
  """
  update_neighborhood_followers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: neighborhood_followers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighborhood_followers_set_input

    """filter the rows which have to be updated"""
    where: neighborhood_followers_bool_exp!
  ): neighborhood_followers_mutation_response

  """
  update single row of the table: "neighborhood_followers"
  """
  update_neighborhood_followers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: neighborhood_followers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighborhood_followers_set_input
    pk_columns: neighborhood_followers_pk_columns_input!
  ): neighborhood_followers

  """
  update multiples rows of table: "neighborhood_followers"
  """
  update_neighborhood_followers_many(
    """updates to execute, in order"""
    updates: [neighborhood_followers_updates!]!
  ): [neighborhood_followers_mutation_response]

  """
  update data of the table: "neighborhoods"
  """
  update_neighborhoods(
    """increments the numeric columns with given value of the filtered values"""
    _inc: neighborhoods_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighborhoods_set_input

    """filter the rows which have to be updated"""
    where: neighborhoods_bool_exp!
  ): neighborhoods_mutation_response

  """
  update single row of the table: "neighborhoods"
  """
  update_neighborhoods_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: neighborhoods_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: neighborhoods_set_input
    pk_columns: neighborhoods_pk_columns_input!
  ): neighborhoods

  """
  update multiples rows of table: "neighborhoods"
  """
  update_neighborhoods_many(
    """updates to execute, in order"""
    updates: [neighborhoods_updates!]!
  ): [neighborhoods_mutation_response]

  """
  update data of the table: "notifications"
  """
  update_notifications(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: notifications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input

    """filter the rows which have to be updated"""
    where: notifications_bool_exp!
  ): notifications_mutation_response

  """
  update single row of the table: "notifications"
  """
  update_notifications_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: notifications_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: notifications_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: notifications_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: notifications_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: notifications_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: notifications_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: notifications_set_input
    pk_columns: notifications_pk_columns_input!
  ): notifications

  """
  update multiples rows of table: "notifications"
  """
  update_notifications_many(
    """updates to execute, in order"""
    updates: [notifications_updates!]!
  ): [notifications_mutation_response]

  """
  update data of the table: "post_comments"
  """
  update_post_comments(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_comments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_comments_set_input

    """filter the rows which have to be updated"""
    where: post_comments_bool_exp!
  ): post_comments_mutation_response

  """
  update single row of the table: "post_comments"
  """
  update_post_comments_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_comments_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_comments_set_input
    pk_columns: post_comments_pk_columns_input!
  ): post_comments

  """
  update multiples rows of table: "post_comments"
  """
  update_post_comments_many(
    """updates to execute, in order"""
    updates: [post_comments_updates!]!
  ): [post_comments_mutation_response]

  """
  update data of the table: "post_reactions"
  """
  update_post_reactions(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_reactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_reactions_set_input

    """filter the rows which have to be updated"""
    where: post_reactions_bool_exp!
  ): post_reactions_mutation_response

  """
  update single row of the table: "post_reactions"
  """
  update_post_reactions_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_reactions_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_reactions_set_input
    pk_columns: post_reactions_pk_columns_input!
  ): post_reactions

  """
  update multiples rows of table: "post_reactions"
  """
  update_post_reactions_many(
    """updates to execute, in order"""
    updates: [post_reactions_updates!]!
  ): [post_reactions_mutation_response]

  """
  update data of the table: "post_shares"
  """
  update_post_shares(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_shares_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_shares_set_input

    """filter the rows which have to be updated"""
    where: post_shares_bool_exp!
  ): post_shares_mutation_response

  """
  update single row of the table: "post_shares"
  """
  update_post_shares_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: post_shares_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: post_shares_set_input
    pk_columns: post_shares_pk_columns_input!
  ): post_shares

  """
  update multiples rows of table: "post_shares"
  """
  update_post_shares_many(
    """updates to execute, in order"""
    updates: [post_shares_updates!]!
  ): [post_shares_mutation_response]

  """
  update data of the table: "posts"
  """
  update_posts(
    """increments the numeric columns with given value of the filtered values"""
    _inc: posts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: posts_set_input

    """filter the rows which have to be updated"""
    where: posts_bool_exp!
  ): posts_mutation_response

  """
  update single row of the table: "posts"
  """
  update_posts_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: posts_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: posts_set_input
    pk_columns: posts_pk_columns_input!
  ): posts

  """
  update multiples rows of table: "posts"
  """
  update_posts_many(
    """updates to execute, in order"""
    updates: [posts_updates!]!
  ): [posts_mutation_response]

  """
  update data of the table: "profiles"
  """
  update_profiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: profiles_set_input

    """filter the rows which have to be updated"""
    where: profiles_bool_exp!
  ): profiles_mutation_response

  """
  update single row of the table: "profiles"
  """
  update_profiles_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: profiles_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: profiles_set_input
    pk_columns: profiles_pk_columns_input!
  ): profiles

  """
  update multiples rows of table: "profiles"
  """
  update_profiles_many(
    """updates to execute, in order"""
    updates: [profiles_updates!]!
  ): [profiles_mutation_response]

  """
  update data of the table: "sessions"
  """
  update_sessions(
    """sets the columns of the filtered rows to the given values"""
    _set: sessions_set_input

    """filter the rows which have to be updated"""
    where: sessions_bool_exp!
  ): sessions_mutation_response

  """
  update single row of the table: "sessions"
  """
  update_sessions_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: sessions_set_input
    pk_columns: sessions_pk_columns_input!
  ): sessions

  """
  update multiples rows of table: "sessions"
  """
  update_sessions_many(
    """updates to execute, in order"""
    updates: [sessions_updates!]!
  ): [sessions_mutation_response]

  """
  update data of the table: "user_neighborhood"
  """
  update_user_neighborhood(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_neighborhood_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_neighborhood_set_input

    """filter the rows which have to be updated"""
    where: user_neighborhood_bool_exp!
  ): user_neighborhood_mutation_response

  """
  update single row of the table: "user_neighborhood"
  """
  update_user_neighborhood_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_neighborhood_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_neighborhood_set_input
    pk_columns: user_neighborhood_pk_columns_input!
  ): user_neighborhood

  """
  update multiples rows of table: "user_neighborhood"
  """
  update_user_neighborhood_many(
    """updates to execute, in order"""
    updates: [user_neighborhood_updates!]!
  ): [user_neighborhood_mutation_response]

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update multiples rows of table: "users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update data of the table: "verification_tokens"
  """
  update_verification_tokens(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_tokens_set_input

    """filter the rows which have to be updated"""
    where: verification_tokens_bool_exp!
  ): verification_tokens_mutation_response

  """
  update single row of the table: "verification_tokens"
  """
  update_verification_tokens_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: verification_tokens_set_input
    pk_columns: verification_tokens_pk_columns_input!
  ): verification_tokens

  """
  update multiples rows of table: "verification_tokens"
  """
  update_verification_tokens_many(
    """updates to execute, in order"""
    updates: [verification_tokens_updates!]!
  ): [verification_tokens_mutation_response]

  """
  update data of the table: "volunteers"
  """
  update_volunteers(
    """increments the numeric columns with given value of the filtered values"""
    _inc: volunteers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: volunteers_set_input

    """filter the rows which have to be updated"""
    where: volunteers_bool_exp!
  ): volunteers_mutation_response

  """
  update single row of the table: "volunteers"
  """
  update_volunteers_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: volunteers_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: volunteers_set_input
    pk_columns: volunteers_pk_columns_input!
  ): volunteers

  """
  update multiples rows of table: "volunteers"
  """
  update_volunteers_many(
    """updates to execute, in order"""
    updates: [volunteers_updates!]!
  ): [volunteers_mutation_response]
}

"""
columns and relationships of "neighborhood_followers"
"""
type neighborhood_followers {
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  neighborhood: neighborhoods!
  neighborhood_id: uuid!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "neighborhood_followers"
"""
type neighborhood_followers_aggregate {
  aggregate: neighborhood_followers_aggregate_fields
  nodes: [neighborhood_followers!]!
}

input neighborhood_followers_aggregate_bool_exp {
  count: neighborhood_followers_aggregate_bool_exp_count
}

input neighborhood_followers_aggregate_bool_exp_count {
  arguments: [neighborhood_followers_select_column!]
  distinct: Boolean
  filter: neighborhood_followers_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "neighborhood_followers"
"""
type neighborhood_followers_aggregate_fields {
  avg: neighborhood_followers_avg_fields
  count(columns: [neighborhood_followers_select_column!], distinct: Boolean): Int!
  max: neighborhood_followers_max_fields
  min: neighborhood_followers_min_fields
  stddev: neighborhood_followers_stddev_fields
  stddev_pop: neighborhood_followers_stddev_pop_fields
  stddev_samp: neighborhood_followers_stddev_samp_fields
  sum: neighborhood_followers_sum_fields
  var_pop: neighborhood_followers_var_pop_fields
  var_samp: neighborhood_followers_var_samp_fields
  variance: neighborhood_followers_variance_fields
}

"""
order by aggregate values of table "neighborhood_followers"
"""
input neighborhood_followers_aggregate_order_by {
  avg: neighborhood_followers_avg_order_by
  count: order_by
  max: neighborhood_followers_max_order_by
  min: neighborhood_followers_min_order_by
  stddev: neighborhood_followers_stddev_order_by
  stddev_pop: neighborhood_followers_stddev_pop_order_by
  stddev_samp: neighborhood_followers_stddev_samp_order_by
  sum: neighborhood_followers_sum_order_by
  var_pop: neighborhood_followers_var_pop_order_by
  var_samp: neighborhood_followers_var_samp_order_by
  variance: neighborhood_followers_variance_order_by
}

"""
input type for inserting array relation for remote table "neighborhood_followers"
"""
input neighborhood_followers_arr_rel_insert_input {
  data: [neighborhood_followers_insert_input!]!

  """upsert condition"""
  on_conflict: neighborhood_followers_on_conflict
}

"""aggregate avg on columns"""
type neighborhood_followers_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "neighborhood_followers". All fields are combined with a logical 'AND'.
"""
input neighborhood_followers_bool_exp {
  _and: [neighborhood_followers_bool_exp!]
  _not: neighborhood_followers_bool_exp
  _or: [neighborhood_followers_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  neighborhood: neighborhoods_bool_exp
  neighborhood_id: uuid_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "neighborhood_followers"
"""
enum neighborhood_followers_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  neighborhood_followers_pkey

  """
  unique or primary key constraint on columns "user_id", "neighborhood_id"
  """
  neighborhood_followers_user_id_neighborhood_id_key
}

"""
input type for incrementing numeric columns in table "neighborhood_followers"
"""
input neighborhood_followers_inc_input {
  id: bigint
}

"""
input type for inserting data into table "neighborhood_followers"
"""
input neighborhood_followers_insert_input {
  created_at: timestamptz
  id: bigint
  neighborhood: neighborhoods_obj_rel_insert_input
  neighborhood_id: uuid
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type neighborhood_followers_max_fields {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_max_order_by {
  created_at: order_by
  id: order_by
  neighborhood_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type neighborhood_followers_min_fields {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_min_order_by {
  created_at: order_by
  id: order_by
  neighborhood_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "neighborhood_followers"
"""
type neighborhood_followers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [neighborhood_followers!]!
}

"""
on_conflict condition type for table "neighborhood_followers"
"""
input neighborhood_followers_on_conflict {
  constraint: neighborhood_followers_constraint!
  update_columns: [neighborhood_followers_update_column!]! = []
  where: neighborhood_followers_bool_exp
}

"""Ordering options when selecting data from "neighborhood_followers"."""
input neighborhood_followers_order_by {
  created_at: order_by
  id: order_by
  neighborhood: neighborhoods_order_by
  neighborhood_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: neighborhood_followers"""
input neighborhood_followers_pk_columns_input {
  id: bigint!
}

"""
select columns of table "neighborhood_followers"
"""
enum neighborhood_followers_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  neighborhood_id

  """column name"""
  user_id
}

"""
input type for updating data in table "neighborhood_followers"
"""
input neighborhood_followers_set_input {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""aggregate stddev on columns"""
type neighborhood_followers_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type neighborhood_followers_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type neighborhood_followers_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "neighborhood_followers"
"""
input neighborhood_followers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: neighborhood_followers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input neighborhood_followers_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""aggregate sum on columns"""
type neighborhood_followers_sum_fields {
  id: bigint
}

"""
order by sum() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_sum_order_by {
  id: order_by
}

"""
update columns of table "neighborhood_followers"
"""
enum neighborhood_followers_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  neighborhood_id

  """column name"""
  user_id
}

input neighborhood_followers_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: neighborhood_followers_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: neighborhood_followers_set_input

  """filter the rows which have to be updated"""
  where: neighborhood_followers_bool_exp!
}

"""aggregate var_pop on columns"""
type neighborhood_followers_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type neighborhood_followers_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type neighborhood_followers_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "neighborhood_followers"
"""
input neighborhood_followers_variance_order_by {
  id: order_by
}

"""
columns and relationships of "neighborhoods"
"""
type neighborhoods {
  center_lat: numeric!
  center_lng: numeric!
  country_code: String!
  created_at: timestamptz!
  created_by: uuid
  description: String!
  district: String
  division: String
  geo_polygon: polygon!
  id: uuid!
  is_verified: Boolean!
  location_type: String!
  name: String!

  """An array relationship"""
  neighborhood_followers(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): [neighborhood_followers!]!

  """An aggregate relationship"""
  neighborhood_followers_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): neighborhood_followers_aggregate!
  slug: String!
  timezone: String
  updated_at: timestamptz!

  """An object relationship"""
  user: users

  """An array relationship"""
  user_neighborhoods(
    """distinct select on columns"""
    distinct_on: [user_neighborhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_neighborhood_order_by!]

    """filter the rows returned"""
    where: user_neighborhood_bool_exp
  ): [user_neighborhood!]!

  """An aggregate relationship"""
  user_neighborhoods_aggregate(
    """distinct select on columns"""
    distinct_on: [user_neighborhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_neighborhood_order_by!]

    """filter the rows returned"""
    where: user_neighborhood_bool_exp
  ): user_neighborhood_aggregate!
}

"""
aggregated selection of "neighborhoods"
"""
type neighborhoods_aggregate {
  aggregate: neighborhoods_aggregate_fields
  nodes: [neighborhoods!]!
}

input neighborhoods_aggregate_bool_exp {
  bool_and: neighborhoods_aggregate_bool_exp_bool_and
  bool_or: neighborhoods_aggregate_bool_exp_bool_or
  count: neighborhoods_aggregate_bool_exp_count
}

input neighborhoods_aggregate_bool_exp_bool_and {
  arguments: neighborhoods_select_column_neighborhoods_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: neighborhoods_bool_exp
  predicate: Boolean_comparison_exp!
}

input neighborhoods_aggregate_bool_exp_bool_or {
  arguments: neighborhoods_select_column_neighborhoods_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: neighborhoods_bool_exp
  predicate: Boolean_comparison_exp!
}

input neighborhoods_aggregate_bool_exp_count {
  arguments: [neighborhoods_select_column!]
  distinct: Boolean
  filter: neighborhoods_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "neighborhoods"
"""
type neighborhoods_aggregate_fields {
  avg: neighborhoods_avg_fields
  count(columns: [neighborhoods_select_column!], distinct: Boolean): Int!
  max: neighborhoods_max_fields
  min: neighborhoods_min_fields
  stddev: neighborhoods_stddev_fields
  stddev_pop: neighborhoods_stddev_pop_fields
  stddev_samp: neighborhoods_stddev_samp_fields
  sum: neighborhoods_sum_fields
  var_pop: neighborhoods_var_pop_fields
  var_samp: neighborhoods_var_samp_fields
  variance: neighborhoods_variance_fields
}

"""
order by aggregate values of table "neighborhoods"
"""
input neighborhoods_aggregate_order_by {
  avg: neighborhoods_avg_order_by
  count: order_by
  max: neighborhoods_max_order_by
  min: neighborhoods_min_order_by
  stddev: neighborhoods_stddev_order_by
  stddev_pop: neighborhoods_stddev_pop_order_by
  stddev_samp: neighborhoods_stddev_samp_order_by
  sum: neighborhoods_sum_order_by
  var_pop: neighborhoods_var_pop_order_by
  var_samp: neighborhoods_var_samp_order_by
  variance: neighborhoods_variance_order_by
}

"""
input type for inserting array relation for remote table "neighborhoods"
"""
input neighborhoods_arr_rel_insert_input {
  data: [neighborhoods_insert_input!]!

  """upsert condition"""
  on_conflict: neighborhoods_on_conflict
}

"""aggregate avg on columns"""
type neighborhoods_avg_fields {
  center_lat: Float
  center_lng: Float
}

"""
order by avg() on columns of table "neighborhoods"
"""
input neighborhoods_avg_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""
Boolean expression to filter rows from the table "neighborhoods". All fields are combined with a logical 'AND'.
"""
input neighborhoods_bool_exp {
  _and: [neighborhoods_bool_exp!]
  _not: neighborhoods_bool_exp
  _or: [neighborhoods_bool_exp!]
  center_lat: numeric_comparison_exp
  center_lng: numeric_comparison_exp
  country_code: String_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: uuid_comparison_exp
  description: String_comparison_exp
  district: String_comparison_exp
  division: String_comparison_exp
  geo_polygon: polygon_comparison_exp
  id: uuid_comparison_exp
  is_verified: Boolean_comparison_exp
  location_type: String_comparison_exp
  name: String_comparison_exp
  neighborhood_followers: neighborhood_followers_bool_exp
  neighborhood_followers_aggregate: neighborhood_followers_aggregate_bool_exp
  slug: String_comparison_exp
  timezone: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_neighborhoods: user_neighborhood_bool_exp
  user_neighborhoods_aggregate: user_neighborhood_aggregate_bool_exp
}

"""
unique or primary key constraints on table "neighborhoods"
"""
enum neighborhoods_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  neighborhoods_pkey

  """
  unique or primary key constraint on columns "slug"
  """
  neighborhoods_slug_key
}

"""
input type for incrementing numeric columns in table "neighborhoods"
"""
input neighborhoods_inc_input {
  center_lat: numeric
  center_lng: numeric
}

"""
input type for inserting data into table "neighborhoods"
"""
input neighborhoods_insert_input {
  center_lat: numeric
  center_lng: numeric
  country_code: String
  created_at: timestamptz
  created_by: uuid
  description: String
  district: String
  division: String
  geo_polygon: polygon
  id: uuid
  is_verified: Boolean
  location_type: String
  name: String
  neighborhood_followers: neighborhood_followers_arr_rel_insert_input
  slug: String
  timezone: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_neighborhoods: user_neighborhood_arr_rel_insert_input
}

"""aggregate max on columns"""
type neighborhoods_max_fields {
  center_lat: numeric
  center_lng: numeric
  country_code: String
  created_at: timestamptz
  created_by: uuid
  description: String
  district: String
  division: String
  id: uuid
  location_type: String
  name: String
  slug: String
  timezone: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "neighborhoods"
"""
input neighborhoods_max_order_by {
  center_lat: order_by
  center_lng: order_by
  country_code: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  district: order_by
  division: order_by
  id: order_by
  location_type: order_by
  name: order_by
  slug: order_by
  timezone: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type neighborhoods_min_fields {
  center_lat: numeric
  center_lng: numeric
  country_code: String
  created_at: timestamptz
  created_by: uuid
  description: String
  district: String
  division: String
  id: uuid
  location_type: String
  name: String
  slug: String
  timezone: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "neighborhoods"
"""
input neighborhoods_min_order_by {
  center_lat: order_by
  center_lng: order_by
  country_code: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  district: order_by
  division: order_by
  id: order_by
  location_type: order_by
  name: order_by
  slug: order_by
  timezone: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "neighborhoods"
"""
type neighborhoods_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [neighborhoods!]!
}

"""
input type for inserting object relation for remote table "neighborhoods"
"""
input neighborhoods_obj_rel_insert_input {
  data: neighborhoods_insert_input!

  """upsert condition"""
  on_conflict: neighborhoods_on_conflict
}

"""
on_conflict condition type for table "neighborhoods"
"""
input neighborhoods_on_conflict {
  constraint: neighborhoods_constraint!
  update_columns: [neighborhoods_update_column!]! = []
  where: neighborhoods_bool_exp
}

"""Ordering options when selecting data from "neighborhoods"."""
input neighborhoods_order_by {
  center_lat: order_by
  center_lng: order_by
  country_code: order_by
  created_at: order_by
  created_by: order_by
  description: order_by
  district: order_by
  division: order_by
  geo_polygon: order_by
  id: order_by
  is_verified: order_by
  location_type: order_by
  name: order_by
  neighborhood_followers_aggregate: neighborhood_followers_aggregate_order_by
  slug: order_by
  timezone: order_by
  updated_at: order_by
  user: users_order_by
  user_neighborhoods_aggregate: user_neighborhood_aggregate_order_by
}

"""primary key columns input for table: neighborhoods"""
input neighborhoods_pk_columns_input {
  id: uuid!
}

"""
select columns of table "neighborhoods"
"""
enum neighborhoods_select_column {
  """column name"""
  center_lat

  """column name"""
  center_lng

  """column name"""
  country_code

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  district

  """column name"""
  division

  """column name"""
  geo_polygon

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  location_type

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  timezone

  """column name"""
  updated_at
}

"""
select "neighborhoods_aggregate_bool_exp_bool_and_arguments_columns" columns of table "neighborhoods"
"""
enum neighborhoods_select_column_neighborhoods_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_verified
}

"""
select "neighborhoods_aggregate_bool_exp_bool_or_arguments_columns" columns of table "neighborhoods"
"""
enum neighborhoods_select_column_neighborhoods_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_verified
}

"""
input type for updating data in table "neighborhoods"
"""
input neighborhoods_set_input {
  center_lat: numeric
  center_lng: numeric
  country_code: String
  created_at: timestamptz
  created_by: uuid
  description: String
  district: String
  division: String
  geo_polygon: polygon
  id: uuid
  is_verified: Boolean
  location_type: String
  name: String
  slug: String
  timezone: String
  updated_at: timestamptz
}

"""aggregate stddev on columns"""
type neighborhoods_stddev_fields {
  center_lat: Float
  center_lng: Float
}

"""
order by stddev() on columns of table "neighborhoods"
"""
input neighborhoods_stddev_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""aggregate stddev_pop on columns"""
type neighborhoods_stddev_pop_fields {
  center_lat: Float
  center_lng: Float
}

"""
order by stddev_pop() on columns of table "neighborhoods"
"""
input neighborhoods_stddev_pop_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""aggregate stddev_samp on columns"""
type neighborhoods_stddev_samp_fields {
  center_lat: Float
  center_lng: Float
}

"""
order by stddev_samp() on columns of table "neighborhoods"
"""
input neighborhoods_stddev_samp_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""
Streaming cursor of the table "neighborhoods"
"""
input neighborhoods_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: neighborhoods_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input neighborhoods_stream_cursor_value_input {
  center_lat: numeric
  center_lng: numeric
  country_code: String
  created_at: timestamptz
  created_by: uuid
  description: String
  district: String
  division: String
  geo_polygon: polygon
  id: uuid
  is_verified: Boolean
  location_type: String
  name: String
  slug: String
  timezone: String
  updated_at: timestamptz
}

"""aggregate sum on columns"""
type neighborhoods_sum_fields {
  center_lat: numeric
  center_lng: numeric
}

"""
order by sum() on columns of table "neighborhoods"
"""
input neighborhoods_sum_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""
update columns of table "neighborhoods"
"""
enum neighborhoods_update_column {
  """column name"""
  center_lat

  """column name"""
  center_lng

  """column name"""
  country_code

  """column name"""
  created_at

  """column name"""
  created_by

  """column name"""
  description

  """column name"""
  district

  """column name"""
  division

  """column name"""
  geo_polygon

  """column name"""
  id

  """column name"""
  is_verified

  """column name"""
  location_type

  """column name"""
  name

  """column name"""
  slug

  """column name"""
  timezone

  """column name"""
  updated_at
}

input neighborhoods_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: neighborhoods_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: neighborhoods_set_input

  """filter the rows which have to be updated"""
  where: neighborhoods_bool_exp!
}

"""aggregate var_pop on columns"""
type neighborhoods_var_pop_fields {
  center_lat: Float
  center_lng: Float
}

"""
order by var_pop() on columns of table "neighborhoods"
"""
input neighborhoods_var_pop_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""aggregate var_samp on columns"""
type neighborhoods_var_samp_fields {
  center_lat: Float
  center_lng: Float
}

"""
order by var_samp() on columns of table "neighborhoods"
"""
input neighborhoods_var_samp_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""aggregate variance on columns"""
type neighborhoods_variance_fields {
  center_lat: Float
  center_lng: Float
}

"""
order by variance() on columns of table "neighborhoods"
"""
input neighborhoods_variance_order_by {
  center_lat: order_by
  center_lng: order_by
}

"""
columns and relationships of "notifications"
"""
type notifications {
  attributes(
    """JSON select path"""
    path: String
  ): jsonb
  created_at: timestamp
  id: Int!
  is_read: Boolean
  message: String

  """An object relationship"""
  recipient: users!
  recipient_id: uuid!

  """An object relationship"""
  sender: users
  sender_id: uuid

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: String!
}

"""
aggregated selection of "notifications"
"""
type notifications_aggregate {
  aggregate: notifications_aggregate_fields
  nodes: [notifications!]!
}

input notifications_aggregate_bool_exp {
  bool_and: notifications_aggregate_bool_exp_bool_and
  bool_or: notifications_aggregate_bool_exp_bool_or
  count: notifications_aggregate_bool_exp_count
}

input notifications_aggregate_bool_exp_bool_and {
  arguments: notifications_select_column_notifications_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input notifications_aggregate_bool_exp_bool_or {
  arguments: notifications_select_column_notifications_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Boolean_comparison_exp!
}

input notifications_aggregate_bool_exp_count {
  arguments: [notifications_select_column!]
  distinct: Boolean
  filter: notifications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "notifications"
"""
type notifications_aggregate_fields {
  avg: notifications_avg_fields
  count(columns: [notifications_select_column!], distinct: Boolean): Int!
  max: notifications_max_fields
  min: notifications_min_fields
  stddev: notifications_stddev_fields
  stddev_pop: notifications_stddev_pop_fields
  stddev_samp: notifications_stddev_samp_fields
  sum: notifications_sum_fields
  var_pop: notifications_var_pop_fields
  var_samp: notifications_var_samp_fields
  variance: notifications_variance_fields
}

"""
order by aggregate values of table "notifications"
"""
input notifications_aggregate_order_by {
  avg: notifications_avg_order_by
  count: order_by
  max: notifications_max_order_by
  min: notifications_min_order_by
  stddev: notifications_stddev_order_by
  stddev_pop: notifications_stddev_pop_order_by
  stddev_samp: notifications_stddev_samp_order_by
  sum: notifications_sum_order_by
  var_pop: notifications_var_pop_order_by
  var_samp: notifications_var_samp_order_by
  variance: notifications_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input notifications_append_input {
  attributes: jsonb
}

"""
input type for inserting array relation for remote table "notifications"
"""
input notifications_arr_rel_insert_input {
  data: [notifications_insert_input!]!

  """upsert condition"""
  on_conflict: notifications_on_conflict
}

"""aggregate avg on columns"""
type notifications_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "notifications"
"""
input notifications_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "notifications". All fields are combined with a logical 'AND'.
"""
input notifications_bool_exp {
  _and: [notifications_bool_exp!]
  _not: notifications_bool_exp
  _or: [notifications_bool_exp!]
  attributes: jsonb_comparison_exp
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  is_read: Boolean_comparison_exp
  message: String_comparison_exp
  recipient: users_bool_exp
  recipient_id: uuid_comparison_exp
  sender: users_bool_exp
  sender_id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "notifications"
"""
enum notifications_constraint {
  """
  unique or primary key constraint on columns "id", "recipient_id"
  """
  notifications_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input notifications_delete_at_path_input {
  attributes: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input notifications_delete_elem_input {
  attributes: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input notifications_delete_key_input {
  attributes: String
}

"""
input type for incrementing numeric columns in table "notifications"
"""
input notifications_inc_input {
  id: Int
}

"""
input type for inserting data into table "notifications"
"""
input notifications_insert_input {
  attributes: jsonb
  created_at: timestamp
  id: Int
  is_read: Boolean
  message: String
  recipient: users_obj_rel_insert_input
  recipient_id: uuid
  sender: users_obj_rel_insert_input
  sender_id: uuid

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: String
}

"""aggregate max on columns"""
type notifications_max_fields {
  created_at: timestamp
  id: Int
  message: String
  recipient_id: uuid
  sender_id: uuid

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: String
}

"""
order by max() on columns of table "notifications"
"""
input notifications_max_order_by {
  created_at: order_by
  id: order_by
  message: order_by
  recipient_id: order_by
  sender_id: order_by

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: order_by
}

"""aggregate min on columns"""
type notifications_min_fields {
  created_at: timestamp
  id: Int
  message: String
  recipient_id: uuid
  sender_id: uuid

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: String
}

"""
order by min() on columns of table "notifications"
"""
input notifications_min_order_by {
  created_at: order_by
  id: order_by
  message: order_by
  recipient_id: order_by
  sender_id: order_by

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: order_by
}

"""
response of any mutation on the table "notifications"
"""
type notifications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [notifications!]!
}

"""
on_conflict condition type for table "notifications"
"""
input notifications_on_conflict {
  constraint: notifications_constraint!
  update_columns: [notifications_update_column!]! = []
  where: notifications_bool_exp
}

"""Ordering options when selecting data from "notifications"."""
input notifications_order_by {
  attributes: order_by
  created_at: order_by
  id: order_by
  is_read: order_by
  message: order_by
  recipient: users_order_by
  recipient_id: order_by
  sender: users_order_by
  sender_id: order_by
  type: order_by
}

"""primary key columns input for table: notifications"""
input notifications_pk_columns_input {
  id: Int!
  recipient_id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input notifications_prepend_input {
  attributes: jsonb
}

"""
select columns of table "notifications"
"""
enum notifications_select_column {
  """column name"""
  attributes

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  recipient_id

  """column name"""
  sender_id

  """column name"""
  type
}

"""
select "notifications_aggregate_bool_exp_bool_and_arguments_columns" columns of table "notifications"
"""
enum notifications_select_column_notifications_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_read
}

"""
select "notifications_aggregate_bool_exp_bool_or_arguments_columns" columns of table "notifications"
"""
enum notifications_select_column_notifications_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_read
}

"""
input type for updating data in table "notifications"
"""
input notifications_set_input {
  attributes: jsonb
  created_at: timestamp
  id: Int
  is_read: Boolean
  message: String
  recipient_id: uuid
  sender_id: uuid

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: String
}

"""aggregate stddev on columns"""
type notifications_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "notifications"
"""
input notifications_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type notifications_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "notifications"
"""
input notifications_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type notifications_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "notifications"
"""
input notifications_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "notifications"
"""
input notifications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: notifications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input notifications_stream_cursor_value_input {
  attributes: jsonb
  created_at: timestamp
  id: Int
  is_read: Boolean
  message: String
  recipient_id: uuid
  sender_id: uuid

  """
  'connect_request', 'message', 'event_invite', 'post_like', 'comment', 'system'
  """
  type: String
}

"""aggregate sum on columns"""
type notifications_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "notifications"
"""
input notifications_sum_order_by {
  id: order_by
}

"""
update columns of table "notifications"
"""
enum notifications_update_column {
  """column name"""
  attributes

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  is_read

  """column name"""
  message

  """column name"""
  recipient_id

  """column name"""
  sender_id

  """column name"""
  type
}

input notifications_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: notifications_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: notifications_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: notifications_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: notifications_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: notifications_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: notifications_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: notifications_set_input

  """filter the rows which have to be updated"""
  where: notifications_bool_exp!
}

"""aggregate var_pop on columns"""
type notifications_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "notifications"
"""
input notifications_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type notifications_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "notifications"
"""
input notifications_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type notifications_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "notifications"
"""
input notifications_variance_order_by {
  id: order_by
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

scalar polygon

"""
Boolean expression to compare columns of type "polygon". All fields are combined with logical 'AND'.
"""
input polygon_comparison_exp {
  _eq: polygon
  _gt: polygon
  _gte: polygon
  _in: [polygon!]
  _is_null: Boolean
  _lt: polygon
  _lte: polygon
  _neq: polygon
  _nin: [polygon!]
}

"""
columns and relationships of "post_comments"
"""
type post_comments {
  content: String!
  created_at: timestamp
  id: bigint!
  media_urls: String
  parent_comment_id: bigint

  """An object relationship"""
  post: posts!
  post_id: bigint!

  """An object relationship"""
  user: users
  user_id: uuid
}

"""
aggregated selection of "post_comments"
"""
type post_comments_aggregate {
  aggregate: post_comments_aggregate_fields
  nodes: [post_comments!]!
}

input post_comments_aggregate_bool_exp {
  count: post_comments_aggregate_bool_exp_count
}

input post_comments_aggregate_bool_exp_count {
  arguments: [post_comments_select_column!]
  distinct: Boolean
  filter: post_comments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "post_comments"
"""
type post_comments_aggregate_fields {
  avg: post_comments_avg_fields
  count(columns: [post_comments_select_column!], distinct: Boolean): Int!
  max: post_comments_max_fields
  min: post_comments_min_fields
  stddev: post_comments_stddev_fields
  stddev_pop: post_comments_stddev_pop_fields
  stddev_samp: post_comments_stddev_samp_fields
  sum: post_comments_sum_fields
  var_pop: post_comments_var_pop_fields
  var_samp: post_comments_var_samp_fields
  variance: post_comments_variance_fields
}

"""
order by aggregate values of table "post_comments"
"""
input post_comments_aggregate_order_by {
  avg: post_comments_avg_order_by
  count: order_by
  max: post_comments_max_order_by
  min: post_comments_min_order_by
  stddev: post_comments_stddev_order_by
  stddev_pop: post_comments_stddev_pop_order_by
  stddev_samp: post_comments_stddev_samp_order_by
  sum: post_comments_sum_order_by
  var_pop: post_comments_var_pop_order_by
  var_samp: post_comments_var_samp_order_by
  variance: post_comments_variance_order_by
}

"""
input type for inserting array relation for remote table "post_comments"
"""
input post_comments_arr_rel_insert_input {
  data: [post_comments_insert_input!]!

  """upsert condition"""
  on_conflict: post_comments_on_conflict
}

"""aggregate avg on columns"""
type post_comments_avg_fields {
  id: Float
  parent_comment_id: Float
  post_id: Float
}

"""
order by avg() on columns of table "post_comments"
"""
input post_comments_avg_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""
Boolean expression to filter rows from the table "post_comments". All fields are combined with a logical 'AND'.
"""
input post_comments_bool_exp {
  _and: [post_comments_bool_exp!]
  _not: post_comments_bool_exp
  _or: [post_comments_bool_exp!]
  content: String_comparison_exp
  created_at: timestamp_comparison_exp
  id: bigint_comparison_exp
  media_urls: String_comparison_exp
  parent_comment_id: bigint_comparison_exp
  post: posts_bool_exp
  post_id: bigint_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "post_comments"
"""
enum post_comments_constraint {
  """
  unique or primary key constraint on columns "post_id", "id"
  """
  comments_pkey
}

"""
input type for incrementing numeric columns in table "post_comments"
"""
input post_comments_inc_input {
  id: bigint
  parent_comment_id: bigint
  post_id: bigint
}

"""
input type for inserting data into table "post_comments"
"""
input post_comments_insert_input {
  content: String
  created_at: timestamp
  id: bigint
  media_urls: String
  parent_comment_id: bigint
  post: posts_obj_rel_insert_input
  post_id: bigint
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type post_comments_max_fields {
  content: String
  created_at: timestamp
  id: bigint
  media_urls: String
  parent_comment_id: bigint
  post_id: bigint
  user_id: uuid
}

"""
order by max() on columns of table "post_comments"
"""
input post_comments_max_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  media_urls: order_by
  parent_comment_id: order_by
  post_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type post_comments_min_fields {
  content: String
  created_at: timestamp
  id: bigint
  media_urls: String
  parent_comment_id: bigint
  post_id: bigint
  user_id: uuid
}

"""
order by min() on columns of table "post_comments"
"""
input post_comments_min_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  media_urls: order_by
  parent_comment_id: order_by
  post_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "post_comments"
"""
type post_comments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [post_comments!]!
}

"""
on_conflict condition type for table "post_comments"
"""
input post_comments_on_conflict {
  constraint: post_comments_constraint!
  update_columns: [post_comments_update_column!]! = []
  where: post_comments_bool_exp
}

"""Ordering options when selecting data from "post_comments"."""
input post_comments_order_by {
  content: order_by
  created_at: order_by
  id: order_by
  media_urls: order_by
  parent_comment_id: order_by
  post: posts_order_by
  post_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: post_comments"""
input post_comments_pk_columns_input {
  id: bigint!
  post_id: bigint!
}

"""
select columns of table "post_comments"
"""
enum post_comments_select_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  media_urls

  """column name"""
  parent_comment_id

  """column name"""
  post_id

  """column name"""
  user_id
}

"""
input type for updating data in table "post_comments"
"""
input post_comments_set_input {
  content: String
  created_at: timestamp
  id: bigint
  media_urls: String
  parent_comment_id: bigint
  post_id: bigint
  user_id: uuid
}

"""aggregate stddev on columns"""
type post_comments_stddev_fields {
  id: Float
  parent_comment_id: Float
  post_id: Float
}

"""
order by stddev() on columns of table "post_comments"
"""
input post_comments_stddev_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""aggregate stddev_pop on columns"""
type post_comments_stddev_pop_fields {
  id: Float
  parent_comment_id: Float
  post_id: Float
}

"""
order by stddev_pop() on columns of table "post_comments"
"""
input post_comments_stddev_pop_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""aggregate stddev_samp on columns"""
type post_comments_stddev_samp_fields {
  id: Float
  parent_comment_id: Float
  post_id: Float
}

"""
order by stddev_samp() on columns of table "post_comments"
"""
input post_comments_stddev_samp_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""
Streaming cursor of the table "post_comments"
"""
input post_comments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: post_comments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input post_comments_stream_cursor_value_input {
  content: String
  created_at: timestamp
  id: bigint
  media_urls: String
  parent_comment_id: bigint
  post_id: bigint
  user_id: uuid
}

"""aggregate sum on columns"""
type post_comments_sum_fields {
  id: bigint
  parent_comment_id: bigint
  post_id: bigint
}

"""
order by sum() on columns of table "post_comments"
"""
input post_comments_sum_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""
update columns of table "post_comments"
"""
enum post_comments_update_column {
  """column name"""
  content

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  media_urls

  """column name"""
  parent_comment_id

  """column name"""
  post_id

  """column name"""
  user_id
}

input post_comments_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: post_comments_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: post_comments_set_input

  """filter the rows which have to be updated"""
  where: post_comments_bool_exp!
}

"""aggregate var_pop on columns"""
type post_comments_var_pop_fields {
  id: Float
  parent_comment_id: Float
  post_id: Float
}

"""
order by var_pop() on columns of table "post_comments"
"""
input post_comments_var_pop_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""aggregate var_samp on columns"""
type post_comments_var_samp_fields {
  id: Float
  parent_comment_id: Float
  post_id: Float
}

"""
order by var_samp() on columns of table "post_comments"
"""
input post_comments_var_samp_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""aggregate variance on columns"""
type post_comments_variance_fields {
  id: Float
  parent_comment_id: Float
  post_id: Float
}

"""
order by variance() on columns of table "post_comments"
"""
input post_comments_variance_order_by {
  id: order_by
  parent_comment_id: order_by
  post_id: order_by
}

"""
columns and relationships of "post_reactions"
"""
type post_reactions {
  created_at: timestamptz

  """An object relationship"""
  post: posts!
  post_id: Int!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "post_reactions"
"""
type post_reactions_aggregate {
  aggregate: post_reactions_aggregate_fields
  nodes: [post_reactions!]!
}

input post_reactions_aggregate_bool_exp {
  count: post_reactions_aggregate_bool_exp_count
}

input post_reactions_aggregate_bool_exp_count {
  arguments: [post_reactions_select_column!]
  distinct: Boolean
  filter: post_reactions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "post_reactions"
"""
type post_reactions_aggregate_fields {
  avg: post_reactions_avg_fields
  count(columns: [post_reactions_select_column!], distinct: Boolean): Int!
  max: post_reactions_max_fields
  min: post_reactions_min_fields
  stddev: post_reactions_stddev_fields
  stddev_pop: post_reactions_stddev_pop_fields
  stddev_samp: post_reactions_stddev_samp_fields
  sum: post_reactions_sum_fields
  var_pop: post_reactions_var_pop_fields
  var_samp: post_reactions_var_samp_fields
  variance: post_reactions_variance_fields
}

"""
order by aggregate values of table "post_reactions"
"""
input post_reactions_aggregate_order_by {
  avg: post_reactions_avg_order_by
  count: order_by
  max: post_reactions_max_order_by
  min: post_reactions_min_order_by
  stddev: post_reactions_stddev_order_by
  stddev_pop: post_reactions_stddev_pop_order_by
  stddev_samp: post_reactions_stddev_samp_order_by
  sum: post_reactions_sum_order_by
  var_pop: post_reactions_var_pop_order_by
  var_samp: post_reactions_var_samp_order_by
  variance: post_reactions_variance_order_by
}

"""
input type for inserting array relation for remote table "post_reactions"
"""
input post_reactions_arr_rel_insert_input {
  data: [post_reactions_insert_input!]!

  """upsert condition"""
  on_conflict: post_reactions_on_conflict
}

"""aggregate avg on columns"""
type post_reactions_avg_fields {
  post_id: Float
}

"""
order by avg() on columns of table "post_reactions"
"""
input post_reactions_avg_order_by {
  post_id: order_by
}

"""
Boolean expression to filter rows from the table "post_reactions". All fields are combined with a logical 'AND'.
"""
input post_reactions_bool_exp {
  _and: [post_reactions_bool_exp!]
  _not: post_reactions_bool_exp
  _or: [post_reactions_bool_exp!]
  created_at: timestamptz_comparison_exp
  post: posts_bool_exp
  post_id: Int_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "post_reactions"
"""
enum post_reactions_constraint {
  """
  unique or primary key constraint on columns "user_id", "post_id"
  """
  post_likes_pkey
}

"""
input type for incrementing numeric columns in table "post_reactions"
"""
input post_reactions_inc_input {
  post_id: Int
}

"""
input type for inserting data into table "post_reactions"
"""
input post_reactions_insert_input {
  created_at: timestamptz
  post: posts_obj_rel_insert_input
  post_id: Int
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type post_reactions_max_fields {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""
order by max() on columns of table "post_reactions"
"""
input post_reactions_max_order_by {
  created_at: order_by
  post_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type post_reactions_min_fields {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""
order by min() on columns of table "post_reactions"
"""
input post_reactions_min_order_by {
  created_at: order_by
  post_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "post_reactions"
"""
type post_reactions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [post_reactions!]!
}

"""
on_conflict condition type for table "post_reactions"
"""
input post_reactions_on_conflict {
  constraint: post_reactions_constraint!
  update_columns: [post_reactions_update_column!]! = []
  where: post_reactions_bool_exp
}

"""Ordering options when selecting data from "post_reactions"."""
input post_reactions_order_by {
  created_at: order_by
  post: posts_order_by
  post_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: post_reactions"""
input post_reactions_pk_columns_input {
  post_id: Int!
  user_id: uuid!
}

"""
select columns of table "post_reactions"
"""
enum post_reactions_select_column {
  """column name"""
  created_at

  """column name"""
  post_id

  """column name"""
  user_id
}

"""
input type for updating data in table "post_reactions"
"""
input post_reactions_set_input {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""aggregate stddev on columns"""
type post_reactions_stddev_fields {
  post_id: Float
}

"""
order by stddev() on columns of table "post_reactions"
"""
input post_reactions_stddev_order_by {
  post_id: order_by
}

"""aggregate stddev_pop on columns"""
type post_reactions_stddev_pop_fields {
  post_id: Float
}

"""
order by stddev_pop() on columns of table "post_reactions"
"""
input post_reactions_stddev_pop_order_by {
  post_id: order_by
}

"""aggregate stddev_samp on columns"""
type post_reactions_stddev_samp_fields {
  post_id: Float
}

"""
order by stddev_samp() on columns of table "post_reactions"
"""
input post_reactions_stddev_samp_order_by {
  post_id: order_by
}

"""
Streaming cursor of the table "post_reactions"
"""
input post_reactions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: post_reactions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input post_reactions_stream_cursor_value_input {
  created_at: timestamptz
  post_id: Int
  user_id: uuid
}

"""aggregate sum on columns"""
type post_reactions_sum_fields {
  post_id: Int
}

"""
order by sum() on columns of table "post_reactions"
"""
input post_reactions_sum_order_by {
  post_id: order_by
}

"""
update columns of table "post_reactions"
"""
enum post_reactions_update_column {
  """column name"""
  created_at

  """column name"""
  post_id

  """column name"""
  user_id
}

input post_reactions_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: post_reactions_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: post_reactions_set_input

  """filter the rows which have to be updated"""
  where: post_reactions_bool_exp!
}

"""aggregate var_pop on columns"""
type post_reactions_var_pop_fields {
  post_id: Float
}

"""
order by var_pop() on columns of table "post_reactions"
"""
input post_reactions_var_pop_order_by {
  post_id: order_by
}

"""aggregate var_samp on columns"""
type post_reactions_var_samp_fields {
  post_id: Float
}

"""
order by var_samp() on columns of table "post_reactions"
"""
input post_reactions_var_samp_order_by {
  post_id: order_by
}

"""aggregate variance on columns"""
type post_reactions_variance_fields {
  post_id: Float
}

"""
order by variance() on columns of table "post_reactions"
"""
input post_reactions_variance_order_by {
  post_id: order_by
}

"""
columns and relationships of "post_shares"
"""
type post_shares {
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  post: posts!
  post_id: bigint!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "post_shares"
"""
type post_shares_aggregate {
  aggregate: post_shares_aggregate_fields
  nodes: [post_shares!]!
}

input post_shares_aggregate_bool_exp {
  count: post_shares_aggregate_bool_exp_count
}

input post_shares_aggregate_bool_exp_count {
  arguments: [post_shares_select_column!]
  distinct: Boolean
  filter: post_shares_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "post_shares"
"""
type post_shares_aggregate_fields {
  avg: post_shares_avg_fields
  count(columns: [post_shares_select_column!], distinct: Boolean): Int!
  max: post_shares_max_fields
  min: post_shares_min_fields
  stddev: post_shares_stddev_fields
  stddev_pop: post_shares_stddev_pop_fields
  stddev_samp: post_shares_stddev_samp_fields
  sum: post_shares_sum_fields
  var_pop: post_shares_var_pop_fields
  var_samp: post_shares_var_samp_fields
  variance: post_shares_variance_fields
}

"""
order by aggregate values of table "post_shares"
"""
input post_shares_aggregate_order_by {
  avg: post_shares_avg_order_by
  count: order_by
  max: post_shares_max_order_by
  min: post_shares_min_order_by
  stddev: post_shares_stddev_order_by
  stddev_pop: post_shares_stddev_pop_order_by
  stddev_samp: post_shares_stddev_samp_order_by
  sum: post_shares_sum_order_by
  var_pop: post_shares_var_pop_order_by
  var_samp: post_shares_var_samp_order_by
  variance: post_shares_variance_order_by
}

"""
input type for inserting array relation for remote table "post_shares"
"""
input post_shares_arr_rel_insert_input {
  data: [post_shares_insert_input!]!

  """upsert condition"""
  on_conflict: post_shares_on_conflict
}

"""aggregate avg on columns"""
type post_shares_avg_fields {
  id: Float
  post_id: Float
}

"""
order by avg() on columns of table "post_shares"
"""
input post_shares_avg_order_by {
  id: order_by
  post_id: order_by
}

"""
Boolean expression to filter rows from the table "post_shares". All fields are combined with a logical 'AND'.
"""
input post_shares_bool_exp {
  _and: [post_shares_bool_exp!]
  _not: post_shares_bool_exp
  _or: [post_shares_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  post: posts_bool_exp
  post_id: bigint_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "post_shares"
"""
enum post_shares_constraint {
  """
  unique or primary key constraint on columns "post_id", "id"
  """
  post_shares_pkey
}

"""
input type for incrementing numeric columns in table "post_shares"
"""
input post_shares_inc_input {
  id: bigint
  post_id: bigint
}

"""
input type for inserting data into table "post_shares"
"""
input post_shares_insert_input {
  created_at: timestamptz
  id: bigint
  post: posts_obj_rel_insert_input
  post_id: bigint
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type post_shares_max_fields {
  created_at: timestamptz
  id: bigint
  post_id: bigint
  user_id: uuid
}

"""
order by max() on columns of table "post_shares"
"""
input post_shares_max_order_by {
  created_at: order_by
  id: order_by
  post_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type post_shares_min_fields {
  created_at: timestamptz
  id: bigint
  post_id: bigint
  user_id: uuid
}

"""
order by min() on columns of table "post_shares"
"""
input post_shares_min_order_by {
  created_at: order_by
  id: order_by
  post_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "post_shares"
"""
type post_shares_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [post_shares!]!
}

"""
on_conflict condition type for table "post_shares"
"""
input post_shares_on_conflict {
  constraint: post_shares_constraint!
  update_columns: [post_shares_update_column!]! = []
  where: post_shares_bool_exp
}

"""Ordering options when selecting data from "post_shares"."""
input post_shares_order_by {
  created_at: order_by
  id: order_by
  post: posts_order_by
  post_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: post_shares"""
input post_shares_pk_columns_input {
  id: bigint!
  post_id: bigint!
}

"""
select columns of table "post_shares"
"""
enum post_shares_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  user_id
}

"""
input type for updating data in table "post_shares"
"""
input post_shares_set_input {
  created_at: timestamptz
  id: bigint
  post_id: bigint
  user_id: uuid
}

"""aggregate stddev on columns"""
type post_shares_stddev_fields {
  id: Float
  post_id: Float
}

"""
order by stddev() on columns of table "post_shares"
"""
input post_shares_stddev_order_by {
  id: order_by
  post_id: order_by
}

"""aggregate stddev_pop on columns"""
type post_shares_stddev_pop_fields {
  id: Float
  post_id: Float
}

"""
order by stddev_pop() on columns of table "post_shares"
"""
input post_shares_stddev_pop_order_by {
  id: order_by
  post_id: order_by
}

"""aggregate stddev_samp on columns"""
type post_shares_stddev_samp_fields {
  id: Float
  post_id: Float
}

"""
order by stddev_samp() on columns of table "post_shares"
"""
input post_shares_stddev_samp_order_by {
  id: order_by
  post_id: order_by
}

"""
Streaming cursor of the table "post_shares"
"""
input post_shares_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: post_shares_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input post_shares_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  post_id: bigint
  user_id: uuid
}

"""aggregate sum on columns"""
type post_shares_sum_fields {
  id: bigint
  post_id: bigint
}

"""
order by sum() on columns of table "post_shares"
"""
input post_shares_sum_order_by {
  id: order_by
  post_id: order_by
}

"""
update columns of table "post_shares"
"""
enum post_shares_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  post_id

  """column name"""
  user_id
}

input post_shares_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: post_shares_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: post_shares_set_input

  """filter the rows which have to be updated"""
  where: post_shares_bool_exp!
}

"""aggregate var_pop on columns"""
type post_shares_var_pop_fields {
  id: Float
  post_id: Float
}

"""
order by var_pop() on columns of table "post_shares"
"""
input post_shares_var_pop_order_by {
  id: order_by
  post_id: order_by
}

"""aggregate var_samp on columns"""
type post_shares_var_samp_fields {
  id: Float
  post_id: Float
}

"""
order by var_samp() on columns of table "post_shares"
"""
input post_shares_var_samp_order_by {
  id: order_by
  post_id: order_by
}

"""aggregate variance on columns"""
type post_shares_variance_fields {
  id: Float
  post_id: Float
}

"""
order by variance() on columns of table "post_shares"
"""
input post_shares_variance_order_by {
  id: order_by
  post_id: order_by
}

"""
columns and relationships of "posts"
"""
type posts {
  """An array relationship"""
  attachments(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An aggregate relationship"""
  attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): attachments_aggregate!

  """An array relationship"""
  bookmarks(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """An aggregate relationship"""
  bookmarks_aggregate(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): bookmarks_aggregate!

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): [post_comments!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): post_comments_aggregate!
  content: String!

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: String
  created_at: timestamp
  deleted_at: timestamp
  id: bigint!
  is_deleted: Boolean
  link_url: String
  media_urls: [String!]

  """An array relationship"""
  post_likes(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): [post_reactions!]!

  """An aggregate relationship"""
  post_likes_aggregate(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): post_reactions_aggregate!

  """An array relationship"""
  post_shares(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): [post_shares!]!

  """An aggregate relationship"""
  post_shares_aggregate(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): post_shares_aggregate!

  """public, private, friends"""
  privacy: String!
  tags: String
  updated_at: timestamp

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "posts"
"""
type posts_aggregate {
  aggregate: posts_aggregate_fields
  nodes: [posts!]!
}

input posts_aggregate_bool_exp {
  bool_and: posts_aggregate_bool_exp_bool_and
  bool_or: posts_aggregate_bool_exp_bool_or
  count: posts_aggregate_bool_exp_count
}

input posts_aggregate_bool_exp_bool_and {
  arguments: posts_select_column_posts_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: posts_bool_exp
  predicate: Boolean_comparison_exp!
}

input posts_aggregate_bool_exp_bool_or {
  arguments: posts_select_column_posts_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: posts_bool_exp
  predicate: Boolean_comparison_exp!
}

input posts_aggregate_bool_exp_count {
  arguments: [posts_select_column!]
  distinct: Boolean
  filter: posts_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "posts"
"""
type posts_aggregate_fields {
  avg: posts_avg_fields
  count(columns: [posts_select_column!], distinct: Boolean): Int!
  max: posts_max_fields
  min: posts_min_fields
  stddev: posts_stddev_fields
  stddev_pop: posts_stddev_pop_fields
  stddev_samp: posts_stddev_samp_fields
  sum: posts_sum_fields
  var_pop: posts_var_pop_fields
  var_samp: posts_var_samp_fields
  variance: posts_variance_fields
}

"""
order by aggregate values of table "posts"
"""
input posts_aggregate_order_by {
  avg: posts_avg_order_by
  count: order_by
  max: posts_max_order_by
  min: posts_min_order_by
  stddev: posts_stddev_order_by
  stddev_pop: posts_stddev_pop_order_by
  stddev_samp: posts_stddev_samp_order_by
  sum: posts_sum_order_by
  var_pop: posts_var_pop_order_by
  var_samp: posts_var_samp_order_by
  variance: posts_variance_order_by
}

"""
input type for inserting array relation for remote table "posts"
"""
input posts_arr_rel_insert_input {
  data: [posts_insert_input!]!

  """upsert condition"""
  on_conflict: posts_on_conflict
}

"""aggregate avg on columns"""
type posts_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "posts"
"""
input posts_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "posts". All fields are combined with a logical 'AND'.
"""
input posts_bool_exp {
  _and: [posts_bool_exp!]
  _not: posts_bool_exp
  _or: [posts_bool_exp!]
  attachments: attachments_bool_exp
  attachments_aggregate: attachments_aggregate_bool_exp
  bookmarks: bookmarks_bool_exp
  bookmarks_aggregate: bookmarks_aggregate_bool_exp
  comments: post_comments_bool_exp
  comments_aggregate: post_comments_aggregate_bool_exp
  content: String_comparison_exp
  content_type: String_comparison_exp
  created_at: timestamp_comparison_exp
  deleted_at: timestamp_comparison_exp
  id: bigint_comparison_exp
  is_deleted: Boolean_comparison_exp
  link_url: String_comparison_exp
  media_urls: String_array_comparison_exp
  post_likes: post_reactions_bool_exp
  post_likes_aggregate: post_reactions_aggregate_bool_exp
  post_shares: post_shares_bool_exp
  post_shares_aggregate: post_shares_aggregate_bool_exp
  privacy: String_comparison_exp
  tags: String_comparison_exp
  updated_at: timestamp_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "posts"
"""
enum posts_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  posts_pkey
}

"""
input type for incrementing numeric columns in table "posts"
"""
input posts_inc_input {
  id: bigint
}

"""
input type for inserting data into table "posts"
"""
input posts_insert_input {
  attachments: attachments_arr_rel_insert_input
  bookmarks: bookmarks_arr_rel_insert_input
  comments: post_comments_arr_rel_insert_input
  content: String

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: String
  created_at: timestamp
  deleted_at: timestamp
  id: bigint
  is_deleted: Boolean
  link_url: String
  media_urls: [String!]
  post_likes: post_reactions_arr_rel_insert_input
  post_shares: post_shares_arr_rel_insert_input

  """public, private, friends"""
  privacy: String
  tags: String
  updated_at: timestamp
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type posts_max_fields {
  content: String

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: String
  created_at: timestamp
  deleted_at: timestamp
  id: bigint
  link_url: String
  media_urls: [String!]

  """public, private, friends"""
  privacy: String
  tags: String
  updated_at: timestamp
  user_id: uuid
}

"""
order by max() on columns of table "posts"
"""
input posts_max_order_by {
  content: order_by

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  link_url: order_by
  media_urls: order_by

  """public, private, friends"""
  privacy: order_by
  tags: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type posts_min_fields {
  content: String

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: String
  created_at: timestamp
  deleted_at: timestamp
  id: bigint
  link_url: String
  media_urls: [String!]

  """public, private, friends"""
  privacy: String
  tags: String
  updated_at: timestamp
  user_id: uuid
}

"""
order by min() on columns of table "posts"
"""
input posts_min_order_by {
  content: order_by

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  link_url: order_by
  media_urls: order_by

  """public, private, friends"""
  privacy: order_by
  tags: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "posts"
"""
type posts_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [posts!]!
}

"""
input type for inserting object relation for remote table "posts"
"""
input posts_obj_rel_insert_input {
  data: posts_insert_input!

  """upsert condition"""
  on_conflict: posts_on_conflict
}

"""
on_conflict condition type for table "posts"
"""
input posts_on_conflict {
  constraint: posts_constraint!
  update_columns: [posts_update_column!]! = []
  where: posts_bool_exp
}

"""Ordering options when selecting data from "posts"."""
input posts_order_by {
  attachments_aggregate: attachments_aggregate_order_by
  bookmarks_aggregate: bookmarks_aggregate_order_by
  comments_aggregate: post_comments_aggregate_order_by
  content: order_by
  content_type: order_by
  created_at: order_by
  deleted_at: order_by
  id: order_by
  is_deleted: order_by
  link_url: order_by
  media_urls: order_by
  post_likes_aggregate: post_reactions_aggregate_order_by
  post_shares_aggregate: post_shares_aggregate_order_by
  privacy: order_by
  tags: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: posts"""
input posts_pk_columns_input {
  id: bigint!
}

"""
select columns of table "posts"
"""
enum posts_select_column {
  """column name"""
  content

  """column name"""
  content_type

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_deleted

  """column name"""
  link_url

  """column name"""
  media_urls

  """column name"""
  privacy

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
select "posts_aggregate_bool_exp_bool_and_arguments_columns" columns of table "posts"
"""
enum posts_select_column_posts_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_deleted
}

"""
select "posts_aggregate_bool_exp_bool_or_arguments_columns" columns of table "posts"
"""
enum posts_select_column_posts_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_deleted
}

"""
input type for updating data in table "posts"
"""
input posts_set_input {
  content: String

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: String
  created_at: timestamp
  deleted_at: timestamp
  id: bigint
  is_deleted: Boolean
  link_url: String
  media_urls: [String!]

  """public, private, friends"""
  privacy: String
  tags: String
  updated_at: timestamp
  user_id: uuid
}

"""aggregate stddev on columns"""
type posts_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "posts"
"""
input posts_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type posts_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "posts"
"""
input posts_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type posts_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "posts"
"""
input posts_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "posts"
"""
input posts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: posts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input posts_stream_cursor_value_input {
  content: String

  """('text', 'image', 'video', 'link', 'event')"""
  content_type: String
  created_at: timestamp
  deleted_at: timestamp
  id: bigint
  is_deleted: Boolean
  link_url: String
  media_urls: [String!]

  """public, private, friends"""
  privacy: String
  tags: String
  updated_at: timestamp
  user_id: uuid
}

"""aggregate sum on columns"""
type posts_sum_fields {
  id: bigint
}

"""
order by sum() on columns of table "posts"
"""
input posts_sum_order_by {
  id: order_by
}

"""
update columns of table "posts"
"""
enum posts_update_column {
  """column name"""
  content

  """column name"""
  content_type

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  id

  """column name"""
  is_deleted

  """column name"""
  link_url

  """column name"""
  media_urls

  """column name"""
  privacy

  """column name"""
  tags

  """column name"""
  updated_at

  """column name"""
  user_id
}

input posts_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: posts_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: posts_set_input

  """filter the rows which have to be updated"""
  where: posts_bool_exp!
}

"""aggregate var_pop on columns"""
type posts_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "posts"
"""
input posts_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type posts_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "posts"
"""
input posts_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type posts_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "posts"
"""
input posts_variance_order_by {
  id: order_by
}

"""
columns and relationships of "profiles"
"""
type profiles {
  address: String
  bio: String
  cover_photo_url: String
  created_at: timestamptz!
  dob: date
  first_name: String!

  """
  A computed field, executes function "get_full_name"
  """
  full_name: String
  gender: String
  interests: [String!]
  is_verified: Boolean!
  last_name: String
  occupation: String
  phone_number: String
  profile_photo_url: String
  trust_score: Int
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
  user_name: String
}

"""
aggregated selection of "profiles"
"""
type profiles_aggregate {
  aggregate: profiles_aggregate_fields
  nodes: [profiles!]!
}

"""
aggregate fields of "profiles"
"""
type profiles_aggregate_fields {
  avg: profiles_avg_fields
  count(columns: [profiles_select_column!], distinct: Boolean): Int!
  max: profiles_max_fields
  min: profiles_min_fields
  stddev: profiles_stddev_fields
  stddev_pop: profiles_stddev_pop_fields
  stddev_samp: profiles_stddev_samp_fields
  sum: profiles_sum_fields
  var_pop: profiles_var_pop_fields
  var_samp: profiles_var_samp_fields
  variance: profiles_variance_fields
}

"""aggregate avg on columns"""
type profiles_avg_fields {
  trust_score: Float
}

"""
Boolean expression to filter rows from the table "profiles". All fields are combined with a logical 'AND'.
"""
input profiles_bool_exp {
  _and: [profiles_bool_exp!]
  _not: profiles_bool_exp
  _or: [profiles_bool_exp!]
  address: String_comparison_exp
  bio: String_comparison_exp
  cover_photo_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  dob: date_comparison_exp
  first_name: String_comparison_exp
  full_name: String_comparison_exp
  gender: String_comparison_exp
  interests: String_array_comparison_exp
  is_verified: Boolean_comparison_exp
  last_name: String_comparison_exp
  occupation: String_comparison_exp
  phone_number: String_comparison_exp
  profile_photo_url: String_comparison_exp
  trust_score: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  user_name: String_comparison_exp
}

"""
unique or primary key constraints on table "profiles"
"""
enum profiles_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  profiles_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  profiles_user_id_key
}

"""
input type for incrementing numeric columns in table "profiles"
"""
input profiles_inc_input {
  trust_score: Int
}

"""
input type for inserting data into table "profiles"
"""
input profiles_insert_input {
  address: String
  bio: String
  cover_photo_url: String
  created_at: timestamptz
  dob: date
  first_name: String
  gender: String
  interests: [String!]
  is_verified: Boolean
  last_name: String
  occupation: String
  phone_number: String
  profile_photo_url: String
  trust_score: Int
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
  user_name: String
}

"""aggregate max on columns"""
type profiles_max_fields {
  address: String
  bio: String
  cover_photo_url: String
  created_at: timestamptz
  dob: date
  first_name: String

  """
  A computed field, executes function "get_full_name"
  """
  full_name: String
  gender: String
  interests: [String!]
  last_name: String
  occupation: String
  phone_number: String
  profile_photo_url: String
  trust_score: Int
  updated_at: timestamptz
  user_id: uuid
  user_name: String
}

"""aggregate min on columns"""
type profiles_min_fields {
  address: String
  bio: String
  cover_photo_url: String
  created_at: timestamptz
  dob: date
  first_name: String

  """
  A computed field, executes function "get_full_name"
  """
  full_name: String
  gender: String
  interests: [String!]
  last_name: String
  occupation: String
  phone_number: String
  profile_photo_url: String
  trust_score: Int
  updated_at: timestamptz
  user_id: uuid
  user_name: String
}

"""
response of any mutation on the table "profiles"
"""
type profiles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [profiles!]!
}

"""
input type for inserting object relation for remote table "profiles"
"""
input profiles_obj_rel_insert_input {
  data: profiles_insert_input!

  """upsert condition"""
  on_conflict: profiles_on_conflict
}

"""
on_conflict condition type for table "profiles"
"""
input profiles_on_conflict {
  constraint: profiles_constraint!
  update_columns: [profiles_update_column!]! = []
  where: profiles_bool_exp
}

"""Ordering options when selecting data from "profiles"."""
input profiles_order_by {
  address: order_by
  bio: order_by
  cover_photo_url: order_by
  created_at: order_by
  dob: order_by
  first_name: order_by
  full_name: order_by
  gender: order_by
  interests: order_by
  is_verified: order_by
  last_name: order_by
  occupation: order_by
  phone_number: order_by
  profile_photo_url: order_by
  trust_score: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
  user_name: order_by
}

"""primary key columns input for table: profiles"""
input profiles_pk_columns_input {
  user_id: uuid!
}

"""
select columns of table "profiles"
"""
enum profiles_select_column {
  """column name"""
  address

  """column name"""
  bio

  """column name"""
  cover_photo_url

  """column name"""
  created_at

  """column name"""
  dob

  """column name"""
  first_name

  """column name"""
  gender

  """column name"""
  interests

  """column name"""
  is_verified

  """column name"""
  last_name

  """column name"""
  occupation

  """column name"""
  phone_number

  """column name"""
  profile_photo_url

  """column name"""
  trust_score

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  user_name
}

"""
input type for updating data in table "profiles"
"""
input profiles_set_input {
  address: String
  bio: String
  cover_photo_url: String
  created_at: timestamptz
  dob: date
  first_name: String
  gender: String
  interests: [String!]
  is_verified: Boolean
  last_name: String
  occupation: String
  phone_number: String
  profile_photo_url: String
  trust_score: Int
  updated_at: timestamptz
  user_id: uuid
  user_name: String
}

"""aggregate stddev on columns"""
type profiles_stddev_fields {
  trust_score: Float
}

"""aggregate stddev_pop on columns"""
type profiles_stddev_pop_fields {
  trust_score: Float
}

"""aggregate stddev_samp on columns"""
type profiles_stddev_samp_fields {
  trust_score: Float
}

"""
Streaming cursor of the table "profiles"
"""
input profiles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: profiles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input profiles_stream_cursor_value_input {
  address: String
  bio: String
  cover_photo_url: String
  created_at: timestamptz
  dob: date
  first_name: String
  gender: String
  interests: [String!]
  is_verified: Boolean
  last_name: String
  occupation: String
  phone_number: String
  profile_photo_url: String
  trust_score: Int
  updated_at: timestamptz
  user_id: uuid
  user_name: String
}

"""aggregate sum on columns"""
type profiles_sum_fields {
  trust_score: Int
}

"""
update columns of table "profiles"
"""
enum profiles_update_column {
  """column name"""
  address

  """column name"""
  bio

  """column name"""
  cover_photo_url

  """column name"""
  created_at

  """column name"""
  dob

  """column name"""
  first_name

  """column name"""
  gender

  """column name"""
  interests

  """column name"""
  is_verified

  """column name"""
  last_name

  """column name"""
  occupation

  """column name"""
  phone_number

  """column name"""
  profile_photo_url

  """column name"""
  trust_score

  """column name"""
  updated_at

  """column name"""
  user_id

  """column name"""
  user_name
}

input profiles_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: profiles_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: profiles_set_input

  """filter the rows which have to be updated"""
  where: profiles_bool_exp!
}

"""aggregate var_pop on columns"""
type profiles_var_pop_fields {
  trust_score: Float
}

"""aggregate var_samp on columns"""
type profiles_var_samp_fields {
  trust_score: Float
}

"""aggregate variance on columns"""
type profiles_variance_fields {
  trust_score: Float
}

type query_root {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: uuid!): accounts

  """An array relationship"""
  attachments(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An aggregate relationship"""
  attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): attachments_aggregate!

  """fetch data from the table: "attachments" using primary key columns"""
  attachments_by_pk(id: Int!): attachments

  """An array relationship"""
  bookmarks(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """An aggregate relationship"""
  bookmarks_aggregate(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): bookmarks_aggregate!

  """fetch data from the table: "bookmarks" using primary key columns"""
  bookmarks_by_pk(post_id: Int!, user_id: uuid!): bookmarks

  """An array relationship"""
  cause_supporters(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): [cause_supporters!]!

  """An aggregate relationship"""
  cause_supporters_aggregate(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): cause_supporters_aggregate!

  """
  fetch data from the table: "cause_supporters" using primary key columns
  """
  cause_supporters_by_pk(id: bigint!): cause_supporters

  """An array relationship"""
  causes(
    """distinct select on columns"""
    distinct_on: [causes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [causes_order_by!]

    """filter the rows returned"""
    where: causes_bool_exp
  ): [causes!]!

  """An aggregate relationship"""
  causes_aggregate(
    """distinct select on columns"""
    distinct_on: [causes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [causes_order_by!]

    """filter the rows returned"""
    where: causes_bool_exp
  ): causes_aggregate!

  """fetch data from the table: "causes" using primary key columns"""
  causes_by_pk(id: uuid!): causes

  """
  fetch data from the table: "connections"
  """
  connections(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): [connections!]!

  """
  fetch aggregated fields from the table: "connections"
  """
  connections_aggregate(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): connections_aggregate!

  """fetch data from the table: "connections" using primary key columns"""
  connections_by_pk(receiver_id: uuid!, sender_id: uuid!): connections

  """An array relationship"""
  conversation_participants(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): [conversation_participants!]!

  """An aggregate relationship"""
  conversation_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): conversation_participants_aggregate!

  """
  fetch data from the table: "conversation_participants" using primary key columns
  """
  conversation_participants_by_pk(id: bigint!): conversation_participants

  """An array relationship"""
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """An aggregate relationship"""
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: Int!): conversations

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: bigint!): messages

  """An array relationship"""
  neighborhood_followers(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): [neighborhood_followers!]!

  """An aggregate relationship"""
  neighborhood_followers_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): neighborhood_followers_aggregate!

  """
  fetch data from the table: "neighborhood_followers" using primary key columns
  """
  neighborhood_followers_by_pk(id: bigint!): neighborhood_followers

  """An array relationship"""
  neighborhoods(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): [neighborhoods!]!

  """An aggregate relationship"""
  neighborhoods_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): neighborhoods_aggregate!

  """fetch data from the table: "neighborhoods" using primary key columns"""
  neighborhoods_by_pk(id: uuid!): neighborhoods

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: Int!, recipient_id: uuid!): notifications

  """
  fetch data from the table: "post_comments"
  """
  post_comments(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): [post_comments!]!

  """
  fetch aggregated fields from the table: "post_comments"
  """
  post_comments_aggregate(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): post_comments_aggregate!

  """fetch data from the table: "post_comments" using primary key columns"""
  post_comments_by_pk(id: bigint!, post_id: bigint!): post_comments

  """
  fetch data from the table: "post_reactions"
  """
  post_reactions(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): [post_reactions!]!

  """
  fetch aggregated fields from the table: "post_reactions"
  """
  post_reactions_aggregate(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): post_reactions_aggregate!

  """fetch data from the table: "post_reactions" using primary key columns"""
  post_reactions_by_pk(post_id: Int!, user_id: uuid!): post_reactions

  """An array relationship"""
  post_shares(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): [post_shares!]!

  """An aggregate relationship"""
  post_shares_aggregate(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): post_shares_aggregate!

  """fetch data from the table: "post_shares" using primary key columns"""
  post_shares_by_pk(id: bigint!, post_id: bigint!): post_shares

  """An array relationship"""
  posts(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): [posts!]!

  """An aggregate relationship"""
  posts_aggregate(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): posts_aggregate!

  """fetch data from the table: "posts" using primary key columns"""
  posts_by_pk(id: bigint!): posts

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): profiles_aggregate!

  """fetch data from the table: "profiles" using primary key columns"""
  profiles_by_pk(user_id: uuid!): profiles

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """fetch data from the table: "sessions" using primary key columns"""
  sessions_by_pk(id: uuid!): sessions

  """
  fetch data from the table: "user_neighborhood"
  """
  user_neighborhood(
    """distinct select on columns"""
    distinct_on: [user_neighborhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_neighborhood_order_by!]

    """filter the rows returned"""
    where: user_neighborhood_bool_exp
  ): [user_neighborhood!]!

  """
  fetch aggregated fields from the table: "user_neighborhood"
  """
  user_neighborhood_aggregate(
    """distinct select on columns"""
    distinct_on: [user_neighborhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_neighborhood_order_by!]

    """filter the rows returned"""
    where: user_neighborhood_bool_exp
  ): user_neighborhood_aggregate!

  """
  fetch data from the table: "user_neighborhood" using primary key columns
  """
  user_neighborhood_by_pk(user_id: uuid!): user_neighborhood

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table: "verification_tokens"
  """
  verification_tokens(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!

  """
  fetch aggregated fields from the table: "verification_tokens"
  """
  verification_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): verification_tokens_aggregate!

  """
  fetch data from the table: "verification_tokens" using primary key columns
  """
  verification_tokens_by_pk(token: String!): verification_tokens

  """An array relationship"""
  volunteers(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): [volunteers!]!

  """An aggregate relationship"""
  volunteers_aggregate(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): volunteers_aggregate!

  """fetch data from the table: "volunteers" using primary key columns"""
  volunteers_by_pk(id: Int!): volunteers
}

"""
columns and relationships of "sessions"
"""
type sessions {
  expires: timestamptz
  id: uuid!
  sessionToken: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "sessions"
"""
type sessions_aggregate {
  aggregate: sessions_aggregate_fields
  nodes: [sessions!]!
}

input sessions_aggregate_bool_exp {
  count: sessions_aggregate_bool_exp_count
}

input sessions_aggregate_bool_exp_count {
  arguments: [sessions_select_column!]
  distinct: Boolean
  filter: sessions_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "sessions"
"""
type sessions_aggregate_fields {
  count(columns: [sessions_select_column!], distinct: Boolean): Int!
  max: sessions_max_fields
  min: sessions_min_fields
}

"""
order by aggregate values of table "sessions"
"""
input sessions_aggregate_order_by {
  count: order_by
  max: sessions_max_order_by
  min: sessions_min_order_by
}

"""
input type for inserting array relation for remote table "sessions"
"""
input sessions_arr_rel_insert_input {
  data: [sessions_insert_input!]!

  """upsert condition"""
  on_conflict: sessions_on_conflict
}

"""
Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'.
"""
input sessions_bool_exp {
  _and: [sessions_bool_exp!]
  _not: sessions_bool_exp
  _or: [sessions_bool_exp!]
  expires: timestamptz_comparison_exp
  id: uuid_comparison_exp
  sessionToken: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "sessions"
"""
enum sessions_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  sessions_pkey
}

"""
input type for inserting data into table "sessions"
"""
input sessions_insert_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type sessions_max_fields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
order by max() on columns of table "sessions"
"""
input sessions_max_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}

"""aggregate min on columns"""
type sessions_min_fields {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
order by min() on columns of table "sessions"
"""
input sessions_min_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  userId: order_by
}

"""
response of any mutation on the table "sessions"
"""
type sessions_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [sessions!]!
}

"""
on_conflict condition type for table "sessions"
"""
input sessions_on_conflict {
  constraint: sessions_constraint!
  update_columns: [sessions_update_column!]! = []
  where: sessions_bool_exp
}

"""Ordering options when selecting data from "sessions"."""
input sessions_order_by {
  expires: order_by
  id: order_by
  sessionToken: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: sessions"""
input sessions_pk_columns_input {
  id: uuid!
}

"""
select columns of table "sessions"
"""
enum sessions_select_column {
  """column name"""
  expires

  """column name"""
  id

  """column name"""
  sessionToken

  """column name"""
  userId
}

"""
input type for updating data in table "sessions"
"""
input sessions_set_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
Streaming cursor of the table "sessions"
"""
input sessions_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: sessions_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input sessions_stream_cursor_value_input {
  expires: timestamptz
  id: uuid
  sessionToken: String
  userId: uuid
}

"""
update columns of table "sessions"
"""
enum sessions_update_column {
  """column name"""
  expires

  """column name"""
  id

  """column name"""
  sessionToken

  """column name"""
  userId
}

input sessions_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: sessions_set_input

  """filter the rows which have to be updated"""
  where: sessions_bool_exp!
}

type subscription_root {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """fetch data from the table: "accounts" using primary key columns"""
  accounts_by_pk(id: uuid!): accounts

  """
  fetch data from the table in a streaming manner: "accounts"
  """
  accounts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [accounts_stream_cursor_input]!

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An array relationship"""
  attachments(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An aggregate relationship"""
  attachments_aggregate(
    """distinct select on columns"""
    distinct_on: [attachments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [attachments_order_by!]

    """filter the rows returned"""
    where: attachments_bool_exp
  ): attachments_aggregate!

  """fetch data from the table: "attachments" using primary key columns"""
  attachments_by_pk(id: Int!): attachments

  """
  fetch data from the table in a streaming manner: "attachments"
  """
  attachments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [attachments_stream_cursor_input]!

    """filter the rows returned"""
    where: attachments_bool_exp
  ): [attachments!]!

  """An array relationship"""
  bookmarks(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """An aggregate relationship"""
  bookmarks_aggregate(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): bookmarks_aggregate!

  """fetch data from the table: "bookmarks" using primary key columns"""
  bookmarks_by_pk(post_id: Int!, user_id: uuid!): bookmarks

  """
  fetch data from the table in a streaming manner: "bookmarks"
  """
  bookmarks_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [bookmarks_stream_cursor_input]!

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """An array relationship"""
  cause_supporters(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): [cause_supporters!]!

  """An aggregate relationship"""
  cause_supporters_aggregate(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): cause_supporters_aggregate!

  """
  fetch data from the table: "cause_supporters" using primary key columns
  """
  cause_supporters_by_pk(id: bigint!): cause_supporters

  """
  fetch data from the table in a streaming manner: "cause_supporters"
  """
  cause_supporters_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [cause_supporters_stream_cursor_input]!

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): [cause_supporters!]!

  """An array relationship"""
  causes(
    """distinct select on columns"""
    distinct_on: [causes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [causes_order_by!]

    """filter the rows returned"""
    where: causes_bool_exp
  ): [causes!]!

  """An aggregate relationship"""
  causes_aggregate(
    """distinct select on columns"""
    distinct_on: [causes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [causes_order_by!]

    """filter the rows returned"""
    where: causes_bool_exp
  ): causes_aggregate!

  """fetch data from the table: "causes" using primary key columns"""
  causes_by_pk(id: uuid!): causes

  """
  fetch data from the table in a streaming manner: "causes"
  """
  causes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [causes_stream_cursor_input]!

    """filter the rows returned"""
    where: causes_bool_exp
  ): [causes!]!

  """
  fetch data from the table: "connections"
  """
  connections(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): [connections!]!

  """
  fetch aggregated fields from the table: "connections"
  """
  connections_aggregate(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): connections_aggregate!

  """fetch data from the table: "connections" using primary key columns"""
  connections_by_pk(receiver_id: uuid!, sender_id: uuid!): connections

  """
  fetch data from the table in a streaming manner: "connections"
  """
  connections_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [connections_stream_cursor_input]!

    """filter the rows returned"""
    where: connections_bool_exp
  ): [connections!]!

  """An array relationship"""
  conversation_participants(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): [conversation_participants!]!

  """An aggregate relationship"""
  conversation_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): conversation_participants_aggregate!

  """
  fetch data from the table: "conversation_participants" using primary key columns
  """
  conversation_participants_by_pk(id: bigint!): conversation_participants

  """
  fetch data from the table in a streaming manner: "conversation_participants"
  """
  conversation_participants_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conversation_participants_stream_cursor_input]!

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): [conversation_participants!]!

  """An array relationship"""
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """An aggregate relationship"""
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """fetch data from the table: "conversations" using primary key columns"""
  conversations_by_pk(id: Int!): conversations

  """
  fetch data from the table in a streaming manner: "conversations"
  """
  conversations_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [conversations_stream_cursor_input]!

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """An array relationship"""
  messages(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messages_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!

  """fetch data from the table: "messages" using primary key columns"""
  messages_by_pk(id: bigint!): messages

  """
  fetch data from the table in a streaming manner: "messages"
  """
  messages_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [messages_stream_cursor_input]!

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An array relationship"""
  neighborhood_followers(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): [neighborhood_followers!]!

  """An aggregate relationship"""
  neighborhood_followers_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): neighborhood_followers_aggregate!

  """
  fetch data from the table: "neighborhood_followers" using primary key columns
  """
  neighborhood_followers_by_pk(id: bigint!): neighborhood_followers

  """
  fetch data from the table in a streaming manner: "neighborhood_followers"
  """
  neighborhood_followers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [neighborhood_followers_stream_cursor_input]!

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): [neighborhood_followers!]!

  """An array relationship"""
  neighborhoods(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): [neighborhoods!]!

  """An aggregate relationship"""
  neighborhoods_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): neighborhoods_aggregate!

  """fetch data from the table: "neighborhoods" using primary key columns"""
  neighborhoods_by_pk(id: uuid!): neighborhoods

  """
  fetch data from the table in a streaming manner: "neighborhoods"
  """
  neighborhoods_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [neighborhoods_stream_cursor_input]!

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): [neighborhoods!]!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """fetch data from the table: "notifications" using primary key columns"""
  notifications_by_pk(id: Int!, recipient_id: uuid!): notifications

  """
  fetch data from the table in a streaming manner: "notifications"
  """
  notifications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [notifications_stream_cursor_input]!

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """
  fetch data from the table: "post_comments"
  """
  post_comments(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): [post_comments!]!

  """
  fetch aggregated fields from the table: "post_comments"
  """
  post_comments_aggregate(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): post_comments_aggregate!

  """fetch data from the table: "post_comments" using primary key columns"""
  post_comments_by_pk(id: bigint!, post_id: bigint!): post_comments

  """
  fetch data from the table in a streaming manner: "post_comments"
  """
  post_comments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [post_comments_stream_cursor_input]!

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): [post_comments!]!

  """
  fetch data from the table: "post_reactions"
  """
  post_reactions(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): [post_reactions!]!

  """
  fetch aggregated fields from the table: "post_reactions"
  """
  post_reactions_aggregate(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): post_reactions_aggregate!

  """fetch data from the table: "post_reactions" using primary key columns"""
  post_reactions_by_pk(post_id: Int!, user_id: uuid!): post_reactions

  """
  fetch data from the table in a streaming manner: "post_reactions"
  """
  post_reactions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [post_reactions_stream_cursor_input]!

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): [post_reactions!]!

  """An array relationship"""
  post_shares(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): [post_shares!]!

  """An aggregate relationship"""
  post_shares_aggregate(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): post_shares_aggregate!

  """fetch data from the table: "post_shares" using primary key columns"""
  post_shares_by_pk(id: bigint!, post_id: bigint!): post_shares

  """
  fetch data from the table in a streaming manner: "post_shares"
  """
  post_shares_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [post_shares_stream_cursor_input]!

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): [post_shares!]!

  """An array relationship"""
  posts(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): [posts!]!

  """An aggregate relationship"""
  posts_aggregate(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): posts_aggregate!

  """fetch data from the table: "posts" using primary key columns"""
  posts_by_pk(id: bigint!): posts

  """
  fetch data from the table in a streaming manner: "posts"
  """
  posts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [posts_stream_cursor_input]!

    """filter the rows returned"""
    where: posts_bool_exp
  ): [posts!]!

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): profiles_aggregate!

  """fetch data from the table: "profiles" using primary key columns"""
  profiles_by_pk(user_id: uuid!): profiles

  """
  fetch data from the table in a streaming manner: "profiles"
  """
  profiles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [profiles_stream_cursor_input]!

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """fetch data from the table: "sessions" using primary key columns"""
  sessions_by_pk(id: uuid!): sessions

  """
  fetch data from the table in a streaming manner: "sessions"
  """
  sessions_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [sessions_stream_cursor_input]!

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """
  fetch data from the table: "user_neighborhood"
  """
  user_neighborhood(
    """distinct select on columns"""
    distinct_on: [user_neighborhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_neighborhood_order_by!]

    """filter the rows returned"""
    where: user_neighborhood_bool_exp
  ): [user_neighborhood!]!

  """
  fetch aggregated fields from the table: "user_neighborhood"
  """
  user_neighborhood_aggregate(
    """distinct select on columns"""
    distinct_on: [user_neighborhood_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_neighborhood_order_by!]

    """filter the rows returned"""
    where: user_neighborhood_bool_exp
  ): user_neighborhood_aggregate!

  """
  fetch data from the table: "user_neighborhood" using primary key columns
  """
  user_neighborhood_by_pk(user_id: uuid!): user_neighborhood

  """
  fetch data from the table in a streaming manner: "user_neighborhood"
  """
  user_neighborhood_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_neighborhood_stream_cursor_input]!

    """filter the rows returned"""
    where: user_neighborhood_bool_exp
  ): [user_neighborhood!]!

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users

  """
  fetch data from the table in a streaming manner: "users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch data from the table: "verification_tokens"
  """
  verification_tokens(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!

  """
  fetch aggregated fields from the table: "verification_tokens"
  """
  verification_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [verification_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [verification_tokens_order_by!]

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): verification_tokens_aggregate!

  """
  fetch data from the table: "verification_tokens" using primary key columns
  """
  verification_tokens_by_pk(token: String!): verification_tokens

  """
  fetch data from the table in a streaming manner: "verification_tokens"
  """
  verification_tokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [verification_tokens_stream_cursor_input]!

    """filter the rows returned"""
    where: verification_tokens_bool_exp
  ): [verification_tokens!]!

  """An array relationship"""
  volunteers(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): [volunteers!]!

  """An aggregate relationship"""
  volunteers_aggregate(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): volunteers_aggregate!

  """fetch data from the table: "volunteers" using primary key columns"""
  volunteers_by_pk(id: Int!): volunteers

  """
  fetch data from the table in a streaming manner: "volunteers"
  """
  volunteers_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [volunteers_stream_cursor_input]!

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): [volunteers!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_neighborhood"
"""
type user_neighborhood {
  created_at: timestamptz!
  id: bigint!

  """An object relationship"""
  neighborhood: neighborhoods!
  neighborhood_id: uuid!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "user_neighborhood"
"""
type user_neighborhood_aggregate {
  aggregate: user_neighborhood_aggregate_fields
  nodes: [user_neighborhood!]!
}

input user_neighborhood_aggregate_bool_exp {
  count: user_neighborhood_aggregate_bool_exp_count
}

input user_neighborhood_aggregate_bool_exp_count {
  arguments: [user_neighborhood_select_column!]
  distinct: Boolean
  filter: user_neighborhood_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_neighborhood"
"""
type user_neighborhood_aggregate_fields {
  avg: user_neighborhood_avg_fields
  count(columns: [user_neighborhood_select_column!], distinct: Boolean): Int!
  max: user_neighborhood_max_fields
  min: user_neighborhood_min_fields
  stddev: user_neighborhood_stddev_fields
  stddev_pop: user_neighborhood_stddev_pop_fields
  stddev_samp: user_neighborhood_stddev_samp_fields
  sum: user_neighborhood_sum_fields
  var_pop: user_neighborhood_var_pop_fields
  var_samp: user_neighborhood_var_samp_fields
  variance: user_neighborhood_variance_fields
}

"""
order by aggregate values of table "user_neighborhood"
"""
input user_neighborhood_aggregate_order_by {
  avg: user_neighborhood_avg_order_by
  count: order_by
  max: user_neighborhood_max_order_by
  min: user_neighborhood_min_order_by
  stddev: user_neighborhood_stddev_order_by
  stddev_pop: user_neighborhood_stddev_pop_order_by
  stddev_samp: user_neighborhood_stddev_samp_order_by
  sum: user_neighborhood_sum_order_by
  var_pop: user_neighborhood_var_pop_order_by
  var_samp: user_neighborhood_var_samp_order_by
  variance: user_neighborhood_variance_order_by
}

"""
input type for inserting array relation for remote table "user_neighborhood"
"""
input user_neighborhood_arr_rel_insert_input {
  data: [user_neighborhood_insert_input!]!

  """upsert condition"""
  on_conflict: user_neighborhood_on_conflict
}

"""aggregate avg on columns"""
type user_neighborhood_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "user_neighborhood"
"""
input user_neighborhood_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "user_neighborhood". All fields are combined with a logical 'AND'.
"""
input user_neighborhood_bool_exp {
  _and: [user_neighborhood_bool_exp!]
  _not: user_neighborhood_bool_exp
  _or: [user_neighborhood_bool_exp!]
  created_at: timestamptz_comparison_exp
  id: bigint_comparison_exp
  neighborhood: neighborhoods_bool_exp
  neighborhood_id: uuid_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_neighborhood"
"""
enum user_neighborhood_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  user_neighborhood_pkey

  """
  unique or primary key constraint on columns "user_id", "neighborhood_id"
  """
  user_neighborhood_user_id_neighborhood_id_key
}

"""
input type for incrementing numeric columns in table "user_neighborhood"
"""
input user_neighborhood_inc_input {
  id: bigint
}

"""
input type for inserting data into table "user_neighborhood"
"""
input user_neighborhood_insert_input {
  created_at: timestamptz
  id: bigint
  neighborhood: neighborhoods_obj_rel_insert_input
  neighborhood_id: uuid
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_neighborhood_max_fields {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "user_neighborhood"
"""
input user_neighborhood_max_order_by {
  created_at: order_by
  id: order_by
  neighborhood_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_neighborhood_min_fields {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "user_neighborhood"
"""
input user_neighborhood_min_order_by {
  created_at: order_by
  id: order_by
  neighborhood_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_neighborhood"
"""
type user_neighborhood_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_neighborhood!]!
}

"""
input type for inserting object relation for remote table "user_neighborhood"
"""
input user_neighborhood_obj_rel_insert_input {
  data: user_neighborhood_insert_input!

  """upsert condition"""
  on_conflict: user_neighborhood_on_conflict
}

"""
on_conflict condition type for table "user_neighborhood"
"""
input user_neighborhood_on_conflict {
  constraint: user_neighborhood_constraint!
  update_columns: [user_neighborhood_update_column!]! = []
  where: user_neighborhood_bool_exp
}

"""Ordering options when selecting data from "user_neighborhood"."""
input user_neighborhood_order_by {
  created_at: order_by
  id: order_by
  neighborhood: neighborhoods_order_by
  neighborhood_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_neighborhood"""
input user_neighborhood_pk_columns_input {
  user_id: uuid!
}

"""
select columns of table "user_neighborhood"
"""
enum user_neighborhood_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  neighborhood_id

  """column name"""
  user_id
}

"""
input type for updating data in table "user_neighborhood"
"""
input user_neighborhood_set_input {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""aggregate stddev on columns"""
type user_neighborhood_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "user_neighborhood"
"""
input user_neighborhood_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type user_neighborhood_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "user_neighborhood"
"""
input user_neighborhood_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type user_neighborhood_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "user_neighborhood"
"""
input user_neighborhood_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "user_neighborhood"
"""
input user_neighborhood_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_neighborhood_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_neighborhood_stream_cursor_value_input {
  created_at: timestamptz
  id: bigint
  neighborhood_id: uuid
  user_id: uuid
}

"""aggregate sum on columns"""
type user_neighborhood_sum_fields {
  id: bigint
}

"""
order by sum() on columns of table "user_neighborhood"
"""
input user_neighborhood_sum_order_by {
  id: order_by
}

"""
update columns of table "user_neighborhood"
"""
enum user_neighborhood_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  neighborhood_id

  """column name"""
  user_id
}

input user_neighborhood_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_neighborhood_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_neighborhood_set_input

  """filter the rows which have to be updated"""
  where: user_neighborhood_bool_exp!
}

"""aggregate var_pop on columns"""
type user_neighborhood_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "user_neighborhood"
"""
input user_neighborhood_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type user_neighborhood_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "user_neighborhood"
"""
input user_neighborhood_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type user_neighborhood_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "user_neighborhood"
"""
input user_neighborhood_variance_order_by {
  id: order_by
}

"""
columns and relationships of "users"
"""
type users {
  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): [accounts!]!

  """An aggregate relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [accounts_order_by!]

    """filter the rows returned"""
    where: accounts_bool_exp
  ): accounts_aggregate!

  """An array relationship"""
  bookmarks(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): [bookmarks!]!

  """An aggregate relationship"""
  bookmarks_aggregate(
    """distinct select on columns"""
    distinct_on: [bookmarks_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bookmarks_order_by!]

    """filter the rows returned"""
    where: bookmarks_bool_exp
  ): bookmarks_aggregate!

  """An array relationship"""
  cause_supporters(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): [cause_supporters!]!

  """An aggregate relationship"""
  cause_supporters_aggregate(
    """distinct select on columns"""
    distinct_on: [cause_supporters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [cause_supporters_order_by!]

    """filter the rows returned"""
    where: cause_supporters_bool_exp
  ): cause_supporters_aggregate!

  """An array relationship"""
  causes(
    """distinct select on columns"""
    distinct_on: [causes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [causes_order_by!]

    """filter the rows returned"""
    where: causes_bool_exp
  ): [causes!]!

  """An aggregate relationship"""
  causes_aggregate(
    """distinct select on columns"""
    distinct_on: [causes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [causes_order_by!]

    """filter the rows returned"""
    where: causes_bool_exp
  ): causes_aggregate!

  """An array relationship"""
  comments(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): [post_comments!]!

  """An aggregate relationship"""
  comments_aggregate(
    """distinct select on columns"""
    distinct_on: [post_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_comments_order_by!]

    """filter the rows returned"""
    where: post_comments_bool_exp
  ): post_comments_aggregate!

  """An array relationship"""
  connection_receiver(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): [connections!]!

  """An aggregate relationship"""
  connection_receiver_aggregate(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): connections_aggregate!

  """An array relationship"""
  connection_sender(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): [connections!]!

  """An aggregate relationship"""
  connection_sender_aggregate(
    """distinct select on columns"""
    distinct_on: [connections_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [connections_order_by!]

    """filter the rows returned"""
    where: connections_bool_exp
  ): connections_aggregate!

  """An array relationship"""
  conversation_participants(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): [conversation_participants!]!

  """An aggregate relationship"""
  conversation_participants_aggregate(
    """distinct select on columns"""
    distinct_on: [conversation_participants_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversation_participants_order_by!]

    """filter the rows returned"""
    where: conversation_participants_bool_exp
  ): conversation_participants_aggregate!

  """An array relationship"""
  conversations(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """An array relationship"""
  conversationsByUser2(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): [conversations!]!

  """An aggregate relationship"""
  conversationsByUser2_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!

  """An aggregate relationship"""
  conversations_aggregate(
    """distinct select on columns"""
    distinct_on: [conversations_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [conversations_order_by!]

    """filter the rows returned"""
    where: conversations_bool_exp
  ): conversations_aggregate!
  email: String
  emailVerified: timestamptz
  id: uuid!
  image: String

  """An array relationship"""
  messagesBySenderId(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): [messages!]!

  """An aggregate relationship"""
  messagesBySenderId_aggregate(
    """distinct select on columns"""
    distinct_on: [messages_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [messages_order_by!]

    """filter the rows returned"""
    where: messages_bool_exp
  ): messages_aggregate!
  name: String

  """An array relationship"""
  neighborhood_followers(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): [neighborhood_followers!]!

  """An aggregate relationship"""
  neighborhood_followers_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhood_followers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhood_followers_order_by!]

    """filter the rows returned"""
    where: neighborhood_followers_bool_exp
  ): neighborhood_followers_aggregate!

  """An array relationship"""
  neighborhoods(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): [neighborhoods!]!

  """An aggregate relationship"""
  neighborhoods_aggregate(
    """distinct select on columns"""
    distinct_on: [neighborhoods_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [neighborhoods_order_by!]

    """filter the rows returned"""
    where: neighborhoods_bool_exp
  ): neighborhoods_aggregate!

  """An array relationship"""
  notifications(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An array relationship"""
  notificationsBySenderId(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): [notifications!]!

  """An aggregate relationship"""
  notificationsBySenderId_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!

  """An aggregate relationship"""
  notifications_aggregate(
    """distinct select on columns"""
    distinct_on: [notifications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [notifications_order_by!]

    """filter the rows returned"""
    where: notifications_bool_exp
  ): notifications_aggregate!
  password: String

  """An array relationship"""
  post_likes(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): [post_reactions!]!

  """An aggregate relationship"""
  post_likes_aggregate(
    """distinct select on columns"""
    distinct_on: [post_reactions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_reactions_order_by!]

    """filter the rows returned"""
    where: post_reactions_bool_exp
  ): post_reactions_aggregate!

  """An array relationship"""
  post_shares(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): [post_shares!]!

  """An aggregate relationship"""
  post_shares_aggregate(
    """distinct select on columns"""
    distinct_on: [post_shares_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [post_shares_order_by!]

    """filter the rows returned"""
    where: post_shares_bool_exp
  ): post_shares_aggregate!

  """An array relationship"""
  posts(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): [posts!]!

  """An aggregate relationship"""
  posts_aggregate(
    """distinct select on columns"""
    distinct_on: [posts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [posts_order_by!]

    """filter the rows returned"""
    where: posts_bool_exp
  ): posts_aggregate!

  """An object relationship"""
  profile: profiles

  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): [sessions!]!

  """An aggregate relationship"""
  sessions_aggregate(
    """distinct select on columns"""
    distinct_on: [sessions_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [sessions_order_by!]

    """filter the rows returned"""
    where: sessions_bool_exp
  ): sessions_aggregate!

  """An object relationship"""
  user_neighborhood: user_neighborhood

  """An array relationship"""
  volunteers(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): [volunteers!]!

  """An array relationship"""
  volunteersByUserId(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): [volunteers!]!

  """An aggregate relationship"""
  volunteersByUserId_aggregate(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): volunteers_aggregate!

  """An aggregate relationship"""
  volunteers_aggregate(
    """distinct select on columns"""
    distinct_on: [volunteers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [volunteers_order_by!]

    """filter the rows returned"""
    where: volunteers_bool_exp
  ): volunteers_aggregate!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  accounts: accounts_bool_exp
  accounts_aggregate: accounts_aggregate_bool_exp
  bookmarks: bookmarks_bool_exp
  bookmarks_aggregate: bookmarks_aggregate_bool_exp
  cause_supporters: cause_supporters_bool_exp
  cause_supporters_aggregate: cause_supporters_aggregate_bool_exp
  causes: causes_bool_exp
  causes_aggregate: causes_aggregate_bool_exp
  comments: post_comments_bool_exp
  comments_aggregate: post_comments_aggregate_bool_exp
  connection_receiver: connections_bool_exp
  connection_receiver_aggregate: connections_aggregate_bool_exp
  connection_sender: connections_bool_exp
  connection_sender_aggregate: connections_aggregate_bool_exp
  conversation_participants: conversation_participants_bool_exp
  conversation_participants_aggregate: conversation_participants_aggregate_bool_exp
  conversations: conversations_bool_exp
  conversationsByUser2: conversations_bool_exp
  conversationsByUser2_aggregate: conversations_aggregate_bool_exp
  conversations_aggregate: conversations_aggregate_bool_exp
  email: String_comparison_exp
  emailVerified: timestamptz_comparison_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  messagesBySenderId: messages_bool_exp
  messagesBySenderId_aggregate: messages_aggregate_bool_exp
  name: String_comparison_exp
  neighborhood_followers: neighborhood_followers_bool_exp
  neighborhood_followers_aggregate: neighborhood_followers_aggregate_bool_exp
  neighborhoods: neighborhoods_bool_exp
  neighborhoods_aggregate: neighborhoods_aggregate_bool_exp
  notifications: notifications_bool_exp
  notificationsBySenderId: notifications_bool_exp
  notificationsBySenderId_aggregate: notifications_aggregate_bool_exp
  notifications_aggregate: notifications_aggregate_bool_exp
  password: String_comparison_exp
  post_likes: post_reactions_bool_exp
  post_likes_aggregate: post_reactions_aggregate_bool_exp
  post_shares: post_shares_bool_exp
  post_shares_aggregate: post_shares_aggregate_bool_exp
  posts: posts_bool_exp
  posts_aggregate: posts_aggregate_bool_exp
  profile: profiles_bool_exp
  sessions: sessions_bool_exp
  sessions_aggregate: sessions_aggregate_bool_exp
  user_neighborhood: user_neighborhood_bool_exp
  volunteers: volunteers_bool_exp
  volunteersByUserId: volunteers_bool_exp
  volunteersByUserId_aggregate: volunteers_aggregate_bool_exp
  volunteers_aggregate: volunteers_aggregate_bool_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  accounts: accounts_arr_rel_insert_input
  bookmarks: bookmarks_arr_rel_insert_input
  cause_supporters: cause_supporters_arr_rel_insert_input
  causes: causes_arr_rel_insert_input
  comments: post_comments_arr_rel_insert_input
  connection_receiver: connections_arr_rel_insert_input
  connection_sender: connections_arr_rel_insert_input
  conversation_participants: conversation_participants_arr_rel_insert_input
  conversations: conversations_arr_rel_insert_input
  conversationsByUser2: conversations_arr_rel_insert_input
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  messagesBySenderId: messages_arr_rel_insert_input
  name: String
  neighborhood_followers: neighborhood_followers_arr_rel_insert_input
  neighborhoods: neighborhoods_arr_rel_insert_input
  notifications: notifications_arr_rel_insert_input
  notificationsBySenderId: notifications_arr_rel_insert_input
  password: String
  post_likes: post_reactions_arr_rel_insert_input
  post_shares: post_shares_arr_rel_insert_input
  posts: posts_arr_rel_insert_input
  profile: profiles_obj_rel_insert_input
  sessions: sessions_arr_rel_insert_input
  user_neighborhood: user_neighborhood_obj_rel_insert_input
  volunteers: volunteers_arr_rel_insert_input
  volunteersByUserId: volunteers_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  password: String
}

"""aggregate min on columns"""
type users_min_fields {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  password: String
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "users"."""
input users_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  bookmarks_aggregate: bookmarks_aggregate_order_by
  cause_supporters_aggregate: cause_supporters_aggregate_order_by
  causes_aggregate: causes_aggregate_order_by
  comments_aggregate: post_comments_aggregate_order_by
  connection_receiver_aggregate: connections_aggregate_order_by
  connection_sender_aggregate: connections_aggregate_order_by
  conversation_participants_aggregate: conversation_participants_aggregate_order_by
  conversationsByUser2_aggregate: conversations_aggregate_order_by
  conversations_aggregate: conversations_aggregate_order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  image: order_by
  messagesBySenderId_aggregate: messages_aggregate_order_by
  name: order_by
  neighborhood_followers_aggregate: neighborhood_followers_aggregate_order_by
  neighborhoods_aggregate: neighborhoods_aggregate_order_by
  notificationsBySenderId_aggregate: notifications_aggregate_order_by
  notifications_aggregate: notifications_aggregate_order_by
  password: order_by
  post_likes_aggregate: post_reactions_aggregate_order_by
  post_shares_aggregate: post_shares_aggregate_order_by
  posts_aggregate: posts_aggregate_order_by
  profile: profiles_order_by
  sessions_aggregate: sessions_aggregate_order_by
  user_neighborhood: user_neighborhood_order_by
  volunteersByUserId_aggregate: volunteers_aggregate_order_by
  volunteers_aggregate: volunteers_aggregate_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  password
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  password: String
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  email: String
  emailVerified: timestamptz
  id: uuid
  image: String
  name: String
  password: String
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  password
}

input users_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "verification_tokens"
"""
type verification_tokens {
  expires: timestamptz
  identifier: String!
  token: String!
}

"""
aggregated selection of "verification_tokens"
"""
type verification_tokens_aggregate {
  aggregate: verification_tokens_aggregate_fields
  nodes: [verification_tokens!]!
}

"""
aggregate fields of "verification_tokens"
"""
type verification_tokens_aggregate_fields {
  count(columns: [verification_tokens_select_column!], distinct: Boolean): Int!
  max: verification_tokens_max_fields
  min: verification_tokens_min_fields
}

"""
Boolean expression to filter rows from the table "verification_tokens". All fields are combined with a logical 'AND'.
"""
input verification_tokens_bool_exp {
  _and: [verification_tokens_bool_exp!]
  _not: verification_tokens_bool_exp
  _or: [verification_tokens_bool_exp!]
  expires: timestamptz_comparison_exp
  identifier: String_comparison_exp
  token: String_comparison_exp
}

"""
unique or primary key constraints on table "verification_tokens"
"""
enum verification_tokens_constraint {
  """
  unique or primary key constraint on columns "token"
  """
  verification_tokens_pkey
}

"""
input type for inserting data into table "verification_tokens"
"""
input verification_tokens_insert_input {
  expires: timestamptz
  identifier: String
  token: String
}

"""aggregate max on columns"""
type verification_tokens_max_fields {
  expires: timestamptz
  identifier: String
  token: String
}

"""aggregate min on columns"""
type verification_tokens_min_fields {
  expires: timestamptz
  identifier: String
  token: String
}

"""
response of any mutation on the table "verification_tokens"
"""
type verification_tokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [verification_tokens!]!
}

"""
on_conflict condition type for table "verification_tokens"
"""
input verification_tokens_on_conflict {
  constraint: verification_tokens_constraint!
  update_columns: [verification_tokens_update_column!]! = []
  where: verification_tokens_bool_exp
}

"""Ordering options when selecting data from "verification_tokens"."""
input verification_tokens_order_by {
  expires: order_by
  identifier: order_by
  token: order_by
}

"""primary key columns input for table: verification_tokens"""
input verification_tokens_pk_columns_input {
  token: String!
}

"""
select columns of table "verification_tokens"
"""
enum verification_tokens_select_column {
  """column name"""
  expires

  """column name"""
  identifier

  """column name"""
  token
}

"""
input type for updating data in table "verification_tokens"
"""
input verification_tokens_set_input {
  expires: timestamptz
  identifier: String
  token: String
}

"""
Streaming cursor of the table "verification_tokens"
"""
input verification_tokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: verification_tokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input verification_tokens_stream_cursor_value_input {
  expires: timestamptz
  identifier: String
  token: String
}

"""
update columns of table "verification_tokens"
"""
enum verification_tokens_update_column {
  """column name"""
  expires

  """column name"""
  identifier

  """column name"""
  token
}

input verification_tokens_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: verification_tokens_set_input

  """filter the rows which have to be updated"""
  where: verification_tokens_bool_exp!
}

"""
columns and relationships of "volunteers"
"""
type volunteers {
  """An object relationship"""
  cause: causes!
  cause_id: uuid!
  created_at: timestamptz!
  description: String
  email: String
  id: Int!
  name: String!
  phone_number: String
  reviewed_at: timestamptz
  reviewed_by: uuid

  """An object relationship"""
  reviewer: users
  skills: [String!]
  status: String!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "volunteers"
"""
type volunteers_aggregate {
  aggregate: volunteers_aggregate_fields
  nodes: [volunteers!]!
}

input volunteers_aggregate_bool_exp {
  count: volunteers_aggregate_bool_exp_count
}

input volunteers_aggregate_bool_exp_count {
  arguments: [volunteers_select_column!]
  distinct: Boolean
  filter: volunteers_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "volunteers"
"""
type volunteers_aggregate_fields {
  avg: volunteers_avg_fields
  count(columns: [volunteers_select_column!], distinct: Boolean): Int!
  max: volunteers_max_fields
  min: volunteers_min_fields
  stddev: volunteers_stddev_fields
  stddev_pop: volunteers_stddev_pop_fields
  stddev_samp: volunteers_stddev_samp_fields
  sum: volunteers_sum_fields
  var_pop: volunteers_var_pop_fields
  var_samp: volunteers_var_samp_fields
  variance: volunteers_variance_fields
}

"""
order by aggregate values of table "volunteers"
"""
input volunteers_aggregate_order_by {
  avg: volunteers_avg_order_by
  count: order_by
  max: volunteers_max_order_by
  min: volunteers_min_order_by
  stddev: volunteers_stddev_order_by
  stddev_pop: volunteers_stddev_pop_order_by
  stddev_samp: volunteers_stddev_samp_order_by
  sum: volunteers_sum_order_by
  var_pop: volunteers_var_pop_order_by
  var_samp: volunteers_var_samp_order_by
  variance: volunteers_variance_order_by
}

"""
input type for inserting array relation for remote table "volunteers"
"""
input volunteers_arr_rel_insert_input {
  data: [volunteers_insert_input!]!

  """upsert condition"""
  on_conflict: volunteers_on_conflict
}

"""aggregate avg on columns"""
type volunteers_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "volunteers"
"""
input volunteers_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "volunteers". All fields are combined with a logical 'AND'.
"""
input volunteers_bool_exp {
  _and: [volunteers_bool_exp!]
  _not: volunteers_bool_exp
  _or: [volunteers_bool_exp!]
  cause: causes_bool_exp
  cause_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  email: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  phone_number: String_comparison_exp
  reviewed_at: timestamptz_comparison_exp
  reviewed_by: uuid_comparison_exp
  reviewer: users_bool_exp
  skills: String_array_comparison_exp
  status: String_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "volunteers"
"""
enum volunteers_constraint {
  """
  unique or primary key constraint on columns "user_id", "cause_id"
  """
  volunteers_cause_id_user_id_key

  """
  unique or primary key constraint on columns "id"
  """
  volunteers_pkey
}

"""
input type for incrementing numeric columns in table "volunteers"
"""
input volunteers_inc_input {
  id: Int
}

"""
input type for inserting data into table "volunteers"
"""
input volunteers_insert_input {
  cause: causes_obj_rel_insert_input
  cause_id: uuid
  created_at: timestamptz
  description: String
  email: String
  id: Int
  name: String
  phone_number: String
  reviewed_at: timestamptz
  reviewed_by: uuid
  reviewer: users_obj_rel_insert_input
  skills: [String!]
  status: String
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type volunteers_max_fields {
  cause_id: uuid
  created_at: timestamptz
  description: String
  email: String
  id: Int
  name: String
  phone_number: String
  reviewed_at: timestamptz
  reviewed_by: uuid
  skills: [String!]
  status: String
  user_id: uuid
}

"""
order by max() on columns of table "volunteers"
"""
input volunteers_max_order_by {
  cause_id: order_by
  created_at: order_by
  description: order_by
  email: order_by
  id: order_by
  name: order_by
  phone_number: order_by
  reviewed_at: order_by
  reviewed_by: order_by
  skills: order_by
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type volunteers_min_fields {
  cause_id: uuid
  created_at: timestamptz
  description: String
  email: String
  id: Int
  name: String
  phone_number: String
  reviewed_at: timestamptz
  reviewed_by: uuid
  skills: [String!]
  status: String
  user_id: uuid
}

"""
order by min() on columns of table "volunteers"
"""
input volunteers_min_order_by {
  cause_id: order_by
  created_at: order_by
  description: order_by
  email: order_by
  id: order_by
  name: order_by
  phone_number: order_by
  reviewed_at: order_by
  reviewed_by: order_by
  skills: order_by
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "volunteers"
"""
type volunteers_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [volunteers!]!
}

"""
on_conflict condition type for table "volunteers"
"""
input volunteers_on_conflict {
  constraint: volunteers_constraint!
  update_columns: [volunteers_update_column!]! = []
  where: volunteers_bool_exp
}

"""Ordering options when selecting data from "volunteers"."""
input volunteers_order_by {
  cause: causes_order_by
  cause_id: order_by
  created_at: order_by
  description: order_by
  email: order_by
  id: order_by
  name: order_by
  phone_number: order_by
  reviewed_at: order_by
  reviewed_by: order_by
  reviewer: users_order_by
  skills: order_by
  status: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: volunteers"""
input volunteers_pk_columns_input {
  id: Int!
}

"""
select columns of table "volunteers"
"""
enum volunteers_select_column {
  """column name"""
  cause_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  phone_number

  """column name"""
  reviewed_at

  """column name"""
  reviewed_by

  """column name"""
  skills

  """column name"""
  status

  """column name"""
  user_id
}

"""
input type for updating data in table "volunteers"
"""
input volunteers_set_input {
  cause_id: uuid
  created_at: timestamptz
  description: String
  email: String
  id: Int
  name: String
  phone_number: String
  reviewed_at: timestamptz
  reviewed_by: uuid
  skills: [String!]
  status: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type volunteers_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "volunteers"
"""
input volunteers_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type volunteers_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "volunteers"
"""
input volunteers_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type volunteers_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "volunteers"
"""
input volunteers_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "volunteers"
"""
input volunteers_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: volunteers_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input volunteers_stream_cursor_value_input {
  cause_id: uuid
  created_at: timestamptz
  description: String
  email: String
  id: Int
  name: String
  phone_number: String
  reviewed_at: timestamptz
  reviewed_by: uuid
  skills: [String!]
  status: String
  user_id: uuid
}

"""aggregate sum on columns"""
type volunteers_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "volunteers"
"""
input volunteers_sum_order_by {
  id: order_by
}

"""
update columns of table "volunteers"
"""
enum volunteers_update_column {
  """column name"""
  cause_id

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  email

  """column name"""
  id

  """column name"""
  name

  """column name"""
  phone_number

  """column name"""
  reviewed_at

  """column name"""
  reviewed_by

  """column name"""
  skills

  """column name"""
  status

  """column name"""
  user_id
}

input volunteers_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: volunteers_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: volunteers_set_input

  """filter the rows which have to be updated"""
  where: volunteers_bool_exp!
}

"""aggregate var_pop on columns"""
type volunteers_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "volunteers"
"""
input volunteers_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type volunteers_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "volunteers"
"""
input volunteers_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type volunteers_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "volunteers"
"""
input volunteers_variance_order_by {
  id: order_by
}